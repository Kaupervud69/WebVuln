> **OAuth** — это широко используемая структура авторизации, которая позволяет веб-сайтам и веб-приложениям запрашивать ограниченный доступ к учетной записи пользователя в другом приложении. Что особенно важно, OAuth позволяет пользователю предоставлять этот доступ, не раскрывая свои учетные данные для входа запрашивающему приложению. 

# База Оauth

### Как работает OAuth 2.0?

* Клиентское приложение — веб-сайт или веб-приложение, которое хочет получить доступ к данным пользователя.
* Владелец ресурса — пользователь, к данным которого клиентское приложение хочет получить доступ.
* Поставщик услуг OAuth — веб-сайт или приложение, которое контролирует данные пользователя и доступ к ним. Они поддерживают OAuth, предоставляя API для взаимодействия как с сервером авторизации, так и с сервером ресурсов.

Существует множество различных способов реализации фактического процесса OAuth. Они известны как «потоки» OAuth или «типы предоставления».

```«код авторизации»``` и ```«неявный»``` типы предоставления в целом включают следующие этапы:

1. Клиентское приложение запрашивает доступ к подмножеству данных пользователя, указывая, какой тип предоставления он хочет использовать и какой вид доступа он хочет.
2. Пользователю предлагается войти в службу OAuth и явно дать свое согласие на запрошенный доступ.
3. Клиентское приложение получает уникальный токен доступа, который подтверждает, что у него есть разрешение от пользователя на доступ к запрошенным данным. То, как именно это происходит, значительно различается в зависимости от типа предоставления.
4. Клиентское приложение использует этот токен доступа для выполнения вызовов API, извлекая соответствующие данные с сервера ресурсов.

> Хотя OAuth 2.0 является текущим стандартом, некоторые веб-сайты по-прежнему используют устаревшую версию 1a. OAuth 2.0 был написан с нуля, а не разработан непосредственно на основе OAuth 1.0. 

* **Области действия OAuth**

> Поскольку имя области действия представляет собой просто произвольную текстовую строку, формат может существенно различаться у разных поставщиков. Некоторые даже используют полный URI в качестве имени области действия, аналогично конечной точке REST API.

Запрос доступа на чтение к списку контактов:
```
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

## Тип предоставления кода авторизации
* [1. Запрос авторизации](#1-Запрос-авторизации)
* [2. Вход пользователя и согласие](#2-Вход-пользователя-и-согласие)
* [3. Предоставление кода авторизации](#3-Предоставление-кода-авторизации)
* [4. Запрос токена доступа](#4-Запрос-токена-доступа)
* [5. Предоставление токена доступа](#5-Предоставление-токена-доступа)
* [6. Вызов API](#6-Вызов-API)
* [7. Предоставление ресурса](#7-Предоставление-ресурса)

![Тип предоставления кода авторизации](https://github.com/Kaupervud69/WebVuln/blob/main/OAuth/jpeg/oauth-authorization-code-flow.jpg "authcode")

### 1. **Запрос авторизации**

Клиентское приложение отправляет запрос в конечную точку /authorization службы OAuth, запрашивая разрешение на доступ к определенным данным пользователя. 
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Хост: oauth-authorization-server.com
```
Этот запрос содержит следующие важные параметры, обычно предоставляемые в строке запроса:

* ```client_id``` - Обязательный параметр, содержащий уникальный идентификатор клиентского приложения. Это значение генерируется, когда клиентское приложение регистрируется в службе OAuth.
* ```redirect_uri``` - URI, на который должен быть перенаправлен браузер пользователя при отправке кода авторизации клиентскому приложению. Это также известно как «Callback URI» или «Callback Endpoint».
> Многие атаки OAuth основаны на использовании недостатков в проверке этого параметра.
* ```response_type``` - Определяет, какой тип ответа ожидает клиентское приложение и, следовательно, какой поток оно хочет инициировать. Для типа предоставления кода авторизации значение должно быть code.
* ```scope``` - К какому подмножеству данных пользователя клиентское приложение хочет получить доступ. Это могут быть пользовательские области, установленные поставщиком OAuth, или стандартизированные области, определенные спецификацией ```OpenID Connect```.
* ```state``` - уникальное, не поддающееся угадыванию значение, привязанное к текущему сеансу клиентского приложения.
> Служба OAuth должна возвращать это точное значение в ответе вместе с кодом авторизации. Этот параметр служит формой токена CSRF для клиентского приложения, гарантируя, что запрос к его конечной точке /callback исходит от того же человека, который инициировал поток OAuth.

### 2. **Вход пользователя и согласие**

Когда сервер авторизации получает первоначальный запрос, он перенаправляет пользователя на страницу входа, где ему будет предложено войти в свою учетную запись у поставщика OAuth (Vk/OK/Google). Затем им будет представлен список данных, к которым клиентское приложение хочет получить доступ. Это основано на областях, определенных в запросе авторизации.

> После того, как пользователь одобрил заданную область для клиентского приложения, этот шаг будет выполнен автоматически, пока у пользователя все еще есть действительный сеанс со службой OAuth.

### 3. **Предоставление кода авторизации**

Если пользователь соглашается на запрошенный доступ, его браузер будет перенаправлен на конечную точку /callback, указанную в параметре redirect_uri запроса авторизации. Результирующий запрос GET будет содержать код авторизации в качестве параметра запроса.
```
GET /callback?code=a1b2c3d4e5f6g7h8&state=ae13d489bd00e3c24 HTTP/1.1
Хост: client-app.com
```
### 4. **Запрос токена доступа**

После того, как клиентское приложение получает код авторизации, ему необходимо обменять его на токен доступа. Для этого оно отправляет запрос POST с сервера на сервер на конечную точку /token сервиса OAuth. Все коммуникации с этого момента происходят в защищенном обратном канале и, следовательно, обычно не могут быть отслежены или проконтролированы пользователем.
```
POST /token HTTP/1.1
Хост: oauth-authorization-server.com
…
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
```
В дополнение к client_id и коду авторизации вы заметите следующие новые параметры:

* ```client_secret``` - Клиентское приложение должно аутентифицировать себя, включив секретный ключ, который был назначен ему при регистрации в службе OAuth.
* ```grant_type``` - Используется для того, чтобы убедиться, что новая конечная точка знает, какой тип предоставления клиентское приложение хочет использовать. В этом случае это должно быть установлено как authorization_code.

### 5. **Предоставление токена доступа**

Служба OAuth проверит запрос токена доступа. Если все так, как ожидалось, сервер отвечает, предоставляя клиентскому приложению токен доступа с запрошенной областью действия.
```
{
"access_token": "z0y9x8w7v6u5",
"token_type": "Bearer",
"expires_in": 3600,
"scope": "openid profile",
…
}
```
### 6. **Вызов API**

Теперь у клиентского приложения есть код доступа, оно наконец может получить данные пользователя с сервера ресурсов. Для этого оно выполняет вызов API к конечной точке /userinfo службы OAuth. Токен доступа отправляется в заголовке Authorization: Bearer, чтобы подтвердить, что у клиентского приложения есть разрешение на доступ к этим данным.
```
GET /userinfo HTTP/1.1
Хост: oauth-resource-server.com
Authorization: Bearer z0y9x8w7v6u5
```
### 7. **Предоставление ресурса**

Сервер ресурсов должен проверить, что токен действителен и принадлежит текущему клиентскому приложению. Если это так, он ответит, отправив запрошенный ресурс, т. е. данные пользователя, на основе области действия токена доступа.
```
{
"username":"user",
"email":"user@sobaken.net",
…
}
```
Клиентское приложение наконец-то может использовать эти данные по назначению. В случае аутентификации OAuth они обычно используются как идентификатор для предоставления пользователю аутентифицированного сеанса, фактически регистрируя его.

## **Неявный тип предоставления**

* [1.1 Запрос авторизации](#11-Запрос-авторизации)
* [2.1 Вход пользователя и согласие](#21-Вход-пользователя-и-согласие)
* [3.1 Предоставление токена доступа](#31-Предоставление-токена-доступа)
* [4.1 Вызов API](#41-Вызов-API)
* [5.1 Предоставление ресурса](#51-Предоставление-ресурса)

![Неявный тип предоставления](https://github.com/Kaupervud69/WebVuln/blob/main/OAuth/jpeg/oauth-implicit-flow.jpg "implicit-flow")

> Вместо того, чтобы сначала получить код авторизации, а затем обменять его на токен доступа, клиентское приложение получает токен доступа сразу после того, как пользователь дает свое согласие.
>> При использовании неявного типа предоставления все общение происходит через перенаправления браузера - нет безопасного обратного канала, как в потоке кода авторизации.
>>> Неявный тип предоставления больше подходит для одностраничных приложений и собственных настольных приложений, которые не могут легко хранить ```client_secret``` на бэкэнде.

### 1.1 **Запрос авторизации**

Неявный поток начинается во многом так же, как поток кода авторизации. Единственное существенное отличие заключается в том, что параметр ```response_type``` должен быть установлен на ```token```.
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Хост: oauth-authorization-server.com
```
### 2.1 **Вход пользователя и согласие**

Пользователь входит в систему и решает, соглашаться ли на запрошенные разрешения или нет.

### 3.1 **Предоставление токена доступа**

Служба OAuth перенаправит браузер пользователя на ```redirect_uri```, указанный в запросе авторизации. Однако вместо отправки параметра запроса, содержащего код авторизации, она отправит токен доступа и другие данные, специфичные для токена, в виде фрагмента URL.
```
GET /callback#access_token=z0y9x8w7v6u5&token_type=Bearer&expires_in=5000&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Хост: client-app.com
```
> Поскольку токен доступа отправляется во фрагменте URL, он никогда не отправляется напрямую клиентскому приложению. Вместо этого клиентское приложение должно использовать подходящий скрипт для извлечения фрагмента и его сохранения.

### 4.1 **Вызов API**

После того, как клиентское приложение успешно извлекло токен доступа из фрагмента URL, оно может использовать его для выполнения вызовов API к конечной точке ```/userinfo``` службы OAuth. В отличие от потока кода авторизации, это также происходит через браузер.
```
GET /userinfo HTTP/1.1
Хост: oauth-resource-server.com
Authorization: Bearer z0y9x8w7v6u5
```
### 5.1 **Предоставление ресурса**

Сервер ресурсов должен проверить, что токен действителен и принадлежит текущему клиентскому приложению. Если это так, он ответит, отправив запрошенный ресурс, т. е. данные пользователя, на основе области действия, связанной с токеном доступа.
```
{
"username":"user",
"email":"user@sobaken.net"
}
```
> В случае аутентификации OAuth они обычно будут использоваться в качестве идентификатора для предоставления пользователю аутентифицированного сеанса, фактически осуществляя его вход в систему.

# Как возникают уязвимости аутентификации OAuth

* Спецификация OAuth относительно неопределенная и гибкая по своей сути.
> Хотя для базовой функциональности каждого типа гранта требуется несколько обязательных компонентов, подавляющее большинство реализации полностью необязательно. Это включает в себя множество параметров конфигурации, которые необходимы для обеспечения безопасности данных пользователей. Короче говоря, существует множество возможностей для проникновения ненадлежащей практики.

* Отсутствие встроенных функций безопасности.
> Безопасность почти полностью зависит от разработчиков, использующих правильную комбинацию параметров конфигурации и реализующих свои собственные дополнительные меры безопасности поверх, такие как надежная проверка ввода. Нужно многое учесть, и это довольно легко сделать неправильно, если у вас нет опыта работы с OAuth.

* В зависимости от типа гранта, высококонфиденциальные данные также отправляются через браузер, что предоставляет злоумышленнику различные возможности для их перехвата.

* [Уязвимости OAuth](https://github.com/Kaupervud69/WebVuln/edit/main/OAuth/OAuth_vulnerabilities.md)





