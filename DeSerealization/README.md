### **DE/SEREALIZATION**

* **Описание**
* Сериализация — это перевод структуры данных или объекта в битовую последовательность или строку определённого формата. При этом формат может быть разным: JSON, XML, YAML или бинарным. В любом случае на выходе получается поток байтов.Так, любой объект из читаемого кода преобразуется в набор байтов. 
* Десериализация — это обратный процесс. Из потока байтов восстанавливают копию структуры данных или объекта.
* Небезопасная десериализация — это ситуация, когда сайт десериализует данные, которые контролирует пользователь.
	- Чаще всего уязвимость десериализации связана с BAC. Она позволяет хакерам получить несанкционированный доступ к аккаунтам админов и других пользователей. Это как матрёшка: одна уязвимость открывает другую.

* **Виды**
**Манипулирование сериализованными объектами**
* изменение атрибута объекта;
Можно:
    вручную отредактировать объект в виде потока байтов;
    написать скрипт, который создаст и сериализует новый объект.(лучше использовать с бинарными форматами сериализации)
* модификацию типа данных;
    Поиск сериализованных данных при изучении трафика.
    Декодирование (при необходимости).
    Определение потенциально значимого атрибута.
    Изменение типа атрибута.
    Присвоение нового значения атрибуту.
    Кодирование (при необходимости).
    Отправка модифицированного запроса
Если меняешь типы данных в сериализованном объекте, нужно обновить все метки типов и индикаторы длины. Иначе ты испортишь сериализованный объект — его нельзя будет десериализовать.
Это правило действует для всех форматов сериализации.
Для атрибутов типа integer и bool длину значения указывать не нужно.
    i (integer) — число,
    s (string) — строка,
    b (bool) — булево значение.
Пример:
    O:11:"credentials":2:{s:8:"username";s:8:"apushkin";s:8:"password";s:15:"4r1naR0d!onovna";} 
Можно изменить тип атрибута password с string на integer и присвоить ему значение 0. Тогда пароль окажется верным в любом случае, а модифицированные данные будут такими:
    O:11:"credentials":2:{s:8:"username";s:8:"apushkin";s:8:"password";i:0;} 
В PHP 8 и более поздних версиях сравнение 0 == "Example string" оценивается как false, поскольку строки больше не преобразуются неявно в 0 во время сравнения. В результате этот эксплойт невозможен в этих версиях PHP.
Поведение при сравнении буквенно-цифровой строки, которая начинается с цифры, остается прежним в PHP 8. Таким образом, 5 == "5 чего-то" по-прежнему рассматривается как 5 == 5.

* использование функционала приложения;
	Допустим, аватар пользователя привязан к его профилю. Значит, путь к файлу с фотографией хранится в атрибуте image_location объекта $user.
	Если объект $user воссоздали из сериализованного объекта, злоумышленник может передать объект с модифицированным атрибутом image_location. И установить там произвольный путь к файлу. Если личный кабинет позволяет удалить аватар, злоумышленник сможет контролировать удаление файлов с сервера.
	Перехватываем запрос и находим в нём сериализованный объект:
	O:4:"user":2:{s:8:"username";s:5:"amigo";s:14:"image_location";s:22:"/data/users/amigo/avatar.jpg";} 
	Затем модифицируем запрос, меняя путь до файла:
	O:4:"user":2:{s:8:"username";s:5:"amigo";s:14:"image_location";s:11:"/etc/passwd";} 
Используя функциональность приложения, удаляем свой аватар. После этого файл /etc/passwd удалится с сервера, поэтому на нём будет сложно войти в систему.
	
* магические методы;
	магические методы — это те, которые вызываются автоматически.
	
* передача произвольного объекта.
    Изучи все классы.
    Найди классы, которые содержат магические методы десериализации.
    Попробуй найти такой класс, который выполняет опасные операции над управляемыми данными.
    Передай сериализованный объект такого класса, чтобы использовать его магический метод для эксплойта.

* **Точки входа**
* все данные, которые передаются на сайт; (cookie)
* всё, что похоже на сериализованные данные.
* Если у тебя есть доступ к исходному коду, ищи там unserialize().
* Если у тебя есть доступ к исходному коду, ищи метод readObject(). Его применяют для чтения и десериализации данных из InputStream.
	- сериализованные объекты Java всегда начинаются с одних и тех же байтов. В шестнадцатеричном формате они кодируются как **AC ED**
	- В Base64 они начинаются с **rO0**

* **Профит**
* запустить удалённое выполнение кода,  
* повысить свои привилегии в системе,  
* получить неавторизованный доступ к файлам.

* **Защита**
*    Проверка входных данных: валидируй и фильтруй данные до десериализации.
*    Используй безопасные форматы: JSON и XML безопаснее бинарной десериализации.
*    Ограничение разрешённых типов: десериализуй только безопасные классы.
*    Регистрация классов: явно задавай список типов, которые можно десериализовать.
*    Целостность данных: используй цифровые подписи или хеширование, чтобы гарантировать целостность данных.
*    Обновления и патчи: следи за обновлениями используемых библиотек и патчей безопасности.


* **Обход защиты**


