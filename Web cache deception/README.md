> **Обман веб-кеша (WCD)** — это уязвимость безопасности, которая возникает, когда веб-сервер или кеширующий прокси-сервер неверно интерпретирует запрос клиента на веб-ресурс и впоследствии отдает другой, часто более конфиденциальный или приватный ресурс, после того как закеширует его.
> 
> Ключи кэша - состоят из элементов HTTP-запроса. Обычно это включает путь URL и параметры запроса, но также может включать множество других элементов, таких как заголовки и тип контента.

* [Инструменты](#Инструменты)
* [Методология](#Методология)
   * [Кеширование конфиденциальных данных](#Кеширование-конфиденциальных-данных)
   * [Кеширование пользовательского JavaScript](#Кеширование-пользовательского-JavaScript)
   * [Уловки (Tricks)](#Уловки-Tricks)
   * [Обнаружение обмана веб-кеша](#Обнаружение-обмана-веб-кеша)
* [Кеширование CloudFlare](#Кеширование-CloudFlare)
* [URL](#URL)


# Инструменты

*   **[PortSwigger/param-miner](https://github.com/PortSwigger/param-miner)** — Расширение Burp Suite для отравления веб-кеша.

# Методология

**Правила кэшированияЖ**
* **Правила расширения статических файлов** — эти правила соответствуют расширению файла запрошенного ресурса, например, .css для таблиц стилей или .js для файлов JavaScript.
* **Правила статических каталогов** — эти правила соответствуют всем URL-путям, которые начинаются с определенного префикса. Они часто используются для нацеливания на определенные каталоги, которые содержат только статические ресурсы, например ```/static``` или ```/assets```.
* **Правила имен файлов** — эти правила сопоставляют определенные имена файлов с целевыми файлами, которые универсально требуются для веб-операций и редко изменяются, например ```robots.txt``` и ```favicon.ico```.

**Пример обмана веб-кеша:**

Пользователь заставляет авторизованную жертву перейти по ссылке `http://www.example.com/home.php/non-existent.css`

1.  Браузер жертвы запрашивает ресурс `http://www.example.com/home.php/non-existent.css`.
2.  Запрошенный ресурс ищется на кеш-сервере, но не находится (ресурса нет в кеше).
3.  Запрос затем передается на основной сервер.
4.  Основной сервер возвращает содержимое `http://www.example.com/home.php`, скорее всего, с HTTP-заголовками кеширования, которые запрещают кешировать эту страницу.
5.  Ответ проходит через кеш-сервер.
6.  Кеш-сервер определяет, что у файла есть расширение `.css`.
7.  В директории кеша сервер создает папку с именем `home.php` и кеширует поддельный "CSS" файл (`non-existent.css`) внутри нее.
8.  Когда злоумышленник запрашивает `http://www.example.com/home.php/non-existent.css`, запрос отправляется на кеш-сервер, и кеш-сервер возвращает закешированный файл с конфиденциальными данными жертвы из `home.php`.

## Кеширование конфиденциальных данных

**Пример 1 — Обман веб-кеша на главной странице PayPal**

1.  Обычный просмотр, посещение домашней страницы: `https://www.example.com/myaccount/home/`
2.  Открытие вредоносной ссылки: `https://www.example.com/myaccount/home/malicious.css`
3.  Страница отображается как `/home`, и кеш сохраняет страницу.
4.  Открытие приватной вкладки с предыдущим URL: `https://www.example.com/myaccount/home/malicious.css`
5.  Отображается содержимое кеша.

**Пример 2 — Обман веб-кеша на OpenAI**

1.  Злоумышленник создает специальный путь `.css` для эндпоинта `/api/auth/session`.
2.  Злоумышленник распространяет ссылку.
3.  Жертвы переходят по легитимной ссылке.
4.  Ответ кешируется.
5.  Злоумышленник получает JWT-учетные данные.

## Кеширование пользовательского JavaScript

1. Найдите неключевой (un-keyed) вход для отравления кеша
```python
Значения: `User-Agent`
Значения: `Cookie`
Заголовок: `X-Forwarded-Host`
Заголовок: `X-Host`
Заголовок: `X-Forwarded-Server`
Заголовок: `X-Forwarded-Scheme` (заголовок; также в комбинации с `X-Forwarded-Host`)
Заголовок: `X-Original-URL` (Symfony)
Заголовок: `X-Rewrite-URL` (Symfony)
```
2. Атака с отравлением кеша — Пример для неключевого входа `X-Forwarded-Host` (не забудь использовать параметр "buster", чтобы закешировать только эту веб-страницу вместо главной страницы сайта)
```python
GET /test?buster=123 HTTP/1.1
Host: target.com
X-Forwarded-Host: test"><script>alert(1)</script>

HTTP/1.1 200 OK
Cache-Control: public, no-cache
[..]
<meta property="og:image" content="https://test"><script>alert(1)</script>">
```

## Уловки (Tricks)

Следующие форматы URL являются хорошей отправной точкой для проверки функции "кеширования".

*   `https://example.com/app/conversation/.js?test`
*   `https://example.com/app/conversation/;.js`
*   `https://example.com/home.php/non-existent.css`

## Обнаружение обмана веб-кеша

1.  **Обнаружение несоответствий в разделителях:** `/path/<динамический-ресурс>;<статический-ресурс>`
    *   Например: `/settings/profile;script.js`
    *   Если исходный сервер использует `;` как разделитель, а кеш — нет:
        *   Кеш интерпретирует путь как: `/settings/profile;script.js`
        *   Исходный сервер интерпретирует путь как: `/settings/profile`
    *   Другие символы-разделители: [см. список разделителей](https://github.com/Kaupervud69/WebVuln/blob/main/Web%20cache%20deception/Intruder/delim_list.txt).
2.  **Обнаружение нормализации:** `/wcd/..%2fprofile`
    *   Если исходный сервер разрешает последовательность обхода пути, а кеш — нет:
        *   Кеш интерпретирует путь как: `/wcd/..%2fprofile`
        *   Исходный сервер интерпретирует путь как: `/profile`
```
/account/%2e%2e/profile.css  
/account/././profile.css
/account//profile.css
/account/.;/profile.css
....
```
| Сервер / Фреймворк | Разделители | Неоднозначные | Особые разделители |
|-------------------|-----------------|-------------------|-------------------|
| Nginx (proxy_cache) | `?` `&` `/` `.` | `;` | `~` (тильда) для location, `=` |
| Apache (mod_cache) | `?` `&` `/` `.` | `;` `,` | `+` (плюс), `@` |
| OpenLiteSpeed | `?` `&` `/` `.` | `;` `%` | `^` (regex), `*` (wildcard) |
| Varnish Cache | `;` `?` `&` `/` `.` | `,` | `=` (равно в query), `:` |
| Squid Proxy | `?` `&` `/` `.` | - | `@` (для auth), `#` |
| CloudFlare CDN | `;` `?` `&` `/` `.` | - | `_` (подчеркивание), `-` (дефис) |
| Akamai | `?` `&` `/` `.` | `;` `,` | `:` (порты), `*` (wildcard) |
| Fastly | `;` `?` `&` `/` `.` | - | `!` (VCL), `\|` (pipe) |
| AWS CloudFront | `?` `&` `/` `.` | `;` | `$` (Lambda@Edge), `^` |
| Microsoft IIS | `?` `&` `/` `.` | `;` `\` | `\` (обратный слэш), `%` |
| Traefik | `;` `?` `&` `/` `.` | - | `^` (regex), `$` (конец строки) |
| HAProxy | `?` `&` `/` `.` | `;` | `%` (encoding), `[ ]` |
| CDN77 | `?` `&` `/` `.` | `;` `,` | `*` (wildcard), `?` |
| KeyCDN | `?` `&` `/` `.` | - | `()` (скобки), `-` |
| Google Cloud CDN | `?` `&` `/` `.` | `;` | `[ ]` (массивы), `{ }` |
| Bunny CDN | `?` `&` `/` `.` | `;` `,` | `{ }` (правила), `*` |
| Java Spring Boot | `?` `&` `/` `.` | `;` `,` | `{ }` (path vars), `:` |
| Laravel (PHP) | `?` `&` `/` `.` | `;` `#` | `{ }` (параметры), `-` (kebab-case) |
| Django (Python) | `?` `&` `/` `.` | `,` `\|` | `<>` (конвертеры), `^` (regex start) |
| Express.js (Node) | `?` `&` `/` `.` | `;` `:` | `()` (группы), `*` (wildcard) |
| Ruby on Rails | `?` `&` `/` `.` | `;` `,` | `:` (сегменты), `()` (опционально) |
| ASP.NET Core | `?` `&` `/` `.` | `;` `,` | `{ }` (route templates), `:` (constraints) |
| Flask (Python) | `?` `&` `/` `.` | `;` `<` `>` | `< >` (converters), `+` (path保留) |
| Symfony (PHP) | `?` `&` `/` `.` | `;` `,` | `{ }` (placeholders), `_` (route names) |

* Тестирование различных разделителей**
```python
def test_delimiters(base_url):
    delimiters = [';', '?', '&', '#', '|']
    
    for delim in delimiters:
        test_urls = [
            f"{base_url}{delim}test.css",
            f"{base_url}{delim}style.css",
            f"{base_url}/..{delim}test.css",
        ]
        
        for url in test_urls:
            resp = requests.get(url)
            if 'X-Cache' in resp.headers or 'Age' in resp.headers:
                print(f"⚠️  Возможная уязвимость: {url}")
                print(f"   Cache-Status: {resp.headers.get('X-Cache')}")
```
# Кеширование CloudFlare

CloudFlare кеширует ресурс, когда заголовок `Cache-Control` установлен в `public` и `max-age` больше 0.

*   CDN CloudFlare по умолчанию не кеширует HTML.
*   CloudFlare кеширует только на основе **расширения файла**, а не MIME-типа: [cloudflare/default-cache-behavior](https://developers.cloudflare.com/cache/about/default-cache-behavior/).

В CDN Cloudflare можно включить **Защиту от обмана кеша (Cache Deception Armor)**, но по умолчанию она отключена. Когда защита включена, правило проверяет, соответствует ли расширение URL возвращаемому `Content-Type`.

У CloudFlare есть список расширений по умолчанию, которые кешируются за их балансировщиками нагрузки.
||||||||
|---|---|---|---|---|---|---|
| 7Z | CSV | GIF | MIDI | PNG | TIF | ZIP |
| AVI | DOC | GZ | MKV | PPT | TIFF | ZST |
| AVIF | DOCX | ICO | MP3 | PPTX | TTF | CSS |
| APK | DMG | ISO | MP4 | PS | WEBM | FLAC |
| BIN | EJS | JAR | OGG | RAR | WEBP | MID |
| BMP | EOT | JPG | OTF | SVG | WOFF | PLS |
| BZ2 | EPS | JPEG | PDF | SVGZ | WOFF2 | TAR |
| CLASS | EXE | JS | PICT | SWF | XLS | XLSX |

* **Статусы кеша CloudFlare:**

* HIT          - Обслужен из кеша
* MISS         - Не было в кеше, получен с origin
* EXPIRED      - Был в кеше, но просрочен
* BYPASS       - Пропущен кеш (по правилам)
* DYNAMIC      - Динамический контент (не кешируется)

**Исключения и обходы:**
*   Если возвращаемый `Content-Type` — `application/octet-stream`, расширение не имеет значения, поскольку это обычно сигнал браузеру сохранить ресурс, а не отобразить его.
*   Cloudflare разрешает обслуживать `.jpg` как `image/webp` или `.gif` как `video/webm` и другие случаи, которые считаются маловероятными для атак.
*   [Обход Защиты от обмана кеша с использованием файла с расширением .avif — исправлено](https://hackerone.com/reports/1391635)

# URL

* [эксплуатации веб-кэша](https://portswigger.net/research/gotta-cache-em-all)
