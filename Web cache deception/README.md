> **Обман веб-кеша (WCD)** — это уязвимость безопасности, которая возникает, когда веб-сервер или кеширующий прокси-сервер неверно интерпретирует запрос клиента на веб-ресурс и впоследствии отдает другой, часто более конфиденциальный или приватный ресурс, после того как закеширует его.
> 
> Ключи кэша - состоят из элементов HTTP-запроса. Обычно это включает путь URL и параметры запроса, но также может включать множество других элементов, таких как заголовки и тип контента.

* [Инструменты](#Инструменты)
* [Методология](#Методология)
  * [Построение атаки обмана веб-кеша](#Построение-атаки-обмана-веб-кеша)   
  * [Кеширование конфиденциальных данных](#Кеширование-конфиденциальных-данных)
  * [Кеширование пользовательского JavaScript](#Кеширование-пользовательского-JavaScript)
  * [Обнаружение обмана веб-кеша](#Обнаружение-обмана-веб-кеша)
    * [Обнаружение несоответствий в разделителях]
    * [Обнаружение нормализации]
    * [Обнаружение правил кэширования имен файлов]
* [Кеширование CloudFlare](#Кеширование-CloudFlare)
* [URL](#URL)


# Инструменты

* **[PortSwigger/param-miner](https://github.com/PortSwigger/param-miner)** — Расширение Burp Suite для отравления веб-кеша.

# Методология

## Построение атаки обмана веб-кеша

1. Определи целевую конечную точку, которая возвращает динамический ответ, содержащий конфиденциальную информацию. Сосредоточься на конечных точках, которые поддерживают GET, HEAD или OPTIONS methods, поскольку запросы, которые изменяют состояние исходного сервера, обычно не кэшируются.
2. Определи несоответствие в том, как кэш и исходный сервер анализируют путь URL. Это может быть несоответствие в том, как они:
  * Сопоставляют URL с ресурсами.
  * Обрабатывают символы-разделители.
  * Нормализуют пути.
3. Создай вредоносный URL, который использует несоответствие, чтобы обмануть кэш и заставить его сохранить динамический ответ. Когда жертва обращается к URL, ее ответ сохраняется в кэше. Затем отправиь запрос на тот же URL, чтобы получить кэшированный ответ, содержащий данные пользователя. Избегай делать это напрямую в браузере, так как некоторые приложения перенаправляют пользователей без сеанса или делают недействительными локальные данные, что может скрыть уязвимость.

**Правила кэширования**
* ```Правила расширения статических файлов``` — эти правила соответствуют расширению файла запрошенного ресурса, например, .css для таблиц стилей или .js для файлов JavaScript.
* ```Правила статических каталогов``` — эти правила соответствуют всем URL-путям, которые начинаются с определенного префикса. Они часто используются для нацеливания на определенные каталоги, которые содержат только статические ресурсы, например ```/static``` или ```/assets```.
* `Правила имен файлов` — эти правила сопоставляют определенные имена файлов с целевыми файлами, которые универсально требуются для веб-операций и редко изменяются, например ```robots.txt``` и ```favicon.ico```.

**Заголовок X-Cache:**
1. ```X-Cache: hit``` — ответ был предоставлен из кэша.
2. ```X-Cache: miss``` — кэш не содержал ответа на ключ запроса, поэтому он был извлечен с исходного сервера. В большинстве случаев ответ затем кэшируется. Чтобы подтвердить это, отправьте запрос еще раз, чтобы увидеть, обновилось ли значение до hit.
3. ```X-Cache: dynamic``` — исходный сервер динамически сгенерировал содержимое. Обычно это означает, что ответ не подходит для кэширования.
4. ```X-Cache: refresh``` — кэшированное содержимое устарело и его необходимо обновить или повторно проверить.

> Заголовок Cache-Control может включать директиву, указывающую на кэширование, например public с max-age выше 0. Это только предполагает, что ресурс кэшируется. Это не всегда указывает на кэширование, так как кэш иногда может переопределять этот заголовок.
>> Большая разница во времени ответа для одного и того же запроса, может указывать на то, что более быстрый ответ подается из кэша.

**Пример обмана веб-кеша:**

> Пользователь заставляет авторизованную жертву перейти по ссылке `http://www.example.com/home.php/non-existent.css`

1.  Браузер жертвы запрашивает ресурс `http://www.example.com/home.php/non-existent.css`.
2.  Запрошенный ресурс ищется на кеш-сервере, но не находится (ресурса нет в кеше).
3.  Запрос затем передается на основной сервер.
4.  Основной сервер возвращает содержимое `http://www.example.com/home.php`, скорее всего, с HTTP-заголовками кеширования, которые запрещают кешировать эту страницу.
5.  Ответ проходит через кеш-сервер.
6.  Кеш-сервер определяет, что у файла есть расширение `.css`.
7.  В директории кеша сервер создает папку с именем `home.php` и кеширует поддельный "CSS" файл (`non-existent.css`) внутри нее.
8.  Когда злоумышленник запрашивает `http://www.example.com/home.php/non-existent.css`, запрос отправляется на кеш-сервер, и кеш-сервер возвращает закешированный файл с конфиденциальными данными жертвы из `home.php`.

## Кеширование конфиденциальных данных

**Пример 1 — Обман веб-кеша на главной странице PayPal**

1.  Обычный просмотр, посещение домашней страницы: `https://www.example.com/myaccount/home/`
2.  Открытие вредоносной ссылки: `https://www.example.com/myaccount/home/malicious.css`
3.  Страница отображается как `/home`, и кеш сохраняет страницу.
4.  Открытие приватной вкладки с предыдущим URL: `https://www.example.com/myaccount/home/malicious.css`
5.  Отображается содержимое кеша.

**Пример 2 — Обман веб-кеша на OpenAI**

1.  Злоумышленник создает специальный путь `.css` для эндпоинта `/api/auth/session`.
2.  Злоумышленник распространяет ссылку.
3.  Жертвы переходят по легитимной ссылке.
4.  Ответ кешируется.
5.  Злоумышленник получает JWT-учетные данные.

## Кеширование пользовательского JavaScript

1. Найдите неключевой (un-keyed) вход для отравления кеша
```python
Значения: User-Agent
Значения: Cookie
Заголовок: X-Forwarded-Host
Заголовок: X-Host
Заголовок: X-Forwarded-Server
Заголовок: X-Forwarded-Scheme (заголовок; также в комбинации с X-Forwarded-Host)
Заголовок: X-Original-URL (Symfony)
Заголовок: X-Rewrite-URL (Symfony)
```
2. Атака с отравлением кеша — Пример для неключевого входа `X-Forwarded-Host` (не забудь использовать параметр "buster", чтобы закешировать только эту веб-страницу вместо главной страницы сайта)
```python
GET /test?buster=123 HTTP/1.1
Host: target.com
X-Forwarded-Host: test"><script>alert(1)</script>

HTTP/1.1 200 OK
Cache-Control: public, no-cache
[..]
<meta property="og:image" content="https://test"><script>alert(1)</script>">
```

> Следующие форматы URL являются хорошей отправной точкой для проверки функции "кеширования".

*   `https://example.com/app/conversation/.js?test`
*   `https://example.com/app/conversation/;.js`
*   `https://example.com/home.php/non-existent.css`

# Обнаружение обмана веб-кеша

1.  **Обнаружение несоответствий в разделителях:** `/path/<динамический-ресурс>;<статический-ресурс>`
* `/settings/profile;script.js`
* Если исходный сервер использует `;` как разделитель, а кеш — нет:
    * Кеш интерпретирует путь как: `/settings/profile;script.js`
    * Исходный сервер интерпретирует путь как: `/settings/profile`
* Другие символы-разделители: [см. список разделителей](https://github.com/Kaupervud69/WebVuln/blob/main/Web%20cache%20deception/Intruder/delim_list.txt).
  
> Можно использовать несоответствие разделителей, чтобы добавить статическое расширение к пути, который просматривается кэшем, но не исходным сервером. Для этого нужно будет определить символ, который используется в качестве разделителя исходным сервером, но не кэшем.

```
/my-account?abc.js.

Если ответ не содержит признаков кэширования. Это либо указывает, что кэш также использует ? как разделитель пути, либо что у кэша нет правила на основе расширения .js.
```

| Сервер / Фреймворк | Разделители | Неоднозначные | Особые разделители |
|-------------------|-----------------|-------------------|-------------------|
| Nginx (proxy_cache) | `?` `&` `/` `.` | `;` | `~` (тильда) для location, `=` |
| Apache (mod_cache) | `?` `&` `/` `.` | `;` `,` | `+` (плюс), `@` |
| OpenLiteSpeed | `?` `&` `/` `.` | `;` `%` | `^` (regex), `*` (wildcard) |
| Varnish Cache | `;` `?` `&` `/` `.` | `,` | `=` (равно в query), `:` |
| Squid Proxy | `?` `&` `/` `.` | - | `@` (для auth), `#` |
| CloudFlare CDN | `;` `?` `&` `/` `.` | - | `_` (подчеркивание), `-` (дефис) |
| Akamai | `?` `&` `/` `.` | `;` `,` | `:` (порты), `*` (wildcard) |
| Fastly | `;` `?` `&` `/` `.` | - | `!` (VCL), `\|` (pipe) |
| AWS CloudFront | `?` `&` `/` `.` | `;` | `$` (Lambda@Edge), `^` |
| Microsoft IIS | `?` `&` `/` `.` | `;` `\` | `\` (обратный слэш), `%` |
| Traefik | `;` `?` `&` `/` `.` | - | `^` (regex), `$` (конец строки) |
| HAProxy | `?` `&` `/` `.` | `;` | `%` (encoding), `[ ]` |
| CDN77 | `?` `&` `/` `.` | `;` `,` | `*` (wildcard), `?` |
| KeyCDN | `?` `&` `/` `.` | - | `()` (скобки), `-` |
| Google Cloud CDN | `?` `&` `/` `.` | `;` | `[ ]` (массивы), `{ }` |
| Bunny CDN | `?` `&` `/` `.` | `;` `,` | `{ }` (правила), `*` |
| Java Spring Boot | `?` `&` `/` `.` | `;` `,` | `{ }` (path vars), `:` |
| Laravel (PHP) | `?` `&` `/` `.` | `;` `#` | `{ }` (параметры), `-` (kebab-case) |
| Django (Python) | `?` `&` `/` `.` | `,` `\|` | `<>` (конвертеры), `^` (regex start) |
| Express.js (Node) | `?` `&` `/` `.` | `;` `:` | `()` (группы), `*` (wildcard) |
| Ruby on Rails | `?` `&` `/` `.` | `;` `,` | `:` (сегменты), `()` (опционально) |
| ASP.NET Core | `?` `&` `/` `.` | `;` `,` | `{ }` (route templates), `:` (constraints) |
| Flask (Python) | `?` `&` `/` `.` | `;` `<` `>` | `< >` (converters), `+` (path保留) |
| Symfony (PHP) | `?` `&` `/` `.` | `;` `,` | `{ }` (placeholders), `_` (route names) |

_________________

2. **Обнаружение нормализации:** `/wcd/..%2fprofile`
* Если исходный сервер разрешает последовательность обхода пути, а кеш — нет:
*  Отправить запрос на некэшируемый ресурс (неидемпотентный метод, такой как POST.) с последовательностью обхода пути и произвольным каталогом в начале пути. ```/profile на /aaa/..%2fprofile```
    * Кеш интерпретирует путь как: `/wcd/..%2fprofile`
    * Исходный сервер интерпретирует путь как: `/profile`
* Если кеш разрешает последовательность обхода пути:
  * выбрать запрос с кэшированным ответом и повторно отправить запрос с последовательностью обхода пути: `/aaa/..%2fassets/js/stockCheck.js`
    * Если ответ больше не кэшируется, это означает, что кэш не нормализует путь перед его сопоставлением с конечной точкой.
    * Если ответ все еще кэшируется, это может означать, что кэш нормализовал путь к /assets/js/stockCheck.js
  * Изменить `/assets/js/stockCheck.js` на `/assets/..%2fjs/stockCheck.js`
    * Если ответ не кэшируется, кэш декодирует слеш и разрешает сегмент точек во время нормализации, интерпретируя путь как `/js/stockCheck.js`. Это показывает, что есть правило кэширования, основанное на префиксе `/assets`.
    * Если ответ кэшируется, кэш не декодировал слеш или не разрешил сегмент точек, интерпретируя путь как `/assets/..%2fjs/stockCheck.js`.    

> В обоих случаях ответ может быть кэширован из-за другого правила кэширования, например, основанного на расширении файла. Чтобы подтвердить, что правило кэширования основано на статическом каталоге, замените путь после префикса каталога произвольной строкой. Например, `/assets/aaa`. Если ответ все еще кэширован, это подтверждает, что правило кэширования основано на префиксе `/assets`. Обратите внимание, что если ответ не выглядит кэшированным, это не обязательно исключает правило кэширования статического каталога, поскольку иногда ответы 404 не кэшируются.

```python
/account/%2e%2e/profile.css  
/account/././profile.css
/account//profile.css
/account/.;/profile.css
....
```

**Эксплуатация нормализации исходным сервером**
* `/<static-directory-prefix>/..%2f<dynamic-path>`
  * Кэш интерпретирует путь как: `/assets/..%2fprofile`
  * Исходный сервер интерпретирует путь как: `/profile`

**Использование нормализации сервером кеша**
> необходимо определить разделитель, который используется исходным сервером, но не кэшем.
* `/<dynamic-path>%2f%2e%2e%2f<static-directory-prefix>`
  * `/profile;%2f%2e%2e%2fstatic`
    * Кэш интерпретирует путь как: `/static`
    * Исходный сервер интерпретирует путь как: `/profile`
_______________________________

3. **Обнаружение правил кэширования имен файлов**

> Некоторые файлы, такие как robots.txt, index.html и favicon.ico, являются распространенными файлами на веб-серверах. Они часто кэшируются из-за их нечастых изменений. Правила кэширования нацеливаются на эти файлы, сопоставляя точную строку имени файла. Чтобы определить, есть ли правило кэширования имен файлов, отправьте запрос GET для возможного файла и посмотрите, кэшируется ли ответ.

* `/aaa%2f%2e%2e%2findex.html`
  * Если ответ кэширован, это означает, что кэш нормализует путь к `/index.html`.
  * Если ответ не кэширован, это означает, что кэш не декодирует слеш и не разрешает сегмент точки, интерпретируя путь как `/aaa%2f%2e%2e%2findex.html`.

**Эксплуатация несоответствий нормализации**

> Поскольку ответ кэшируется только в том случае, если запрос точно соответствует имени файла, можно использовать несоответствие только тогда, когда сервер кэширования разрешает закодированные сегменты точки, а исходный сервер — нет. Используйте тот же метод, что и для правил кэширования статических каталогов — просто замените префикс статического каталога на имя файла.
____________________
# Кеширование CloudFlare

CloudFlare кеширует ресурс, когда заголовок `Cache-Control` установлен в `public` и `max-age` больше 0.

*   CDN CloudFlare по умолчанию не кеширует HTML.
*   CloudFlare кеширует только на основе **расширения файла**, а не MIME-типа: [cloudflare/default-cache-behavior](https://developers.cloudflare.com/cache/about/default-cache-behavior/).

В CDN Cloudflare можно включить **Защиту от обмана кеша (Cache Deception Armor)**, но по умолчанию она отключена. Когда защита включена, правило проверяет, соответствует ли расширение URL возвращаемому `Content-Type`.

У CloudFlare есть список расширений по умолчанию, которые кешируются за их балансировщиками нагрузки.
||||||||
|---|---|---|---|---|---|---|
| 7Z | CSV | GIF | MIDI | PNG | TIF | ZIP |
| AVI | DOC | GZ | MKV | PPT | TIFF | ZST |
| AVIF | DOCX | ICO | MP3 | PPTX | TTF | CSS |
| APK | DMG | ISO | MP4 | PS | WEBM | FLAC |
| BIN | EJS | JAR | OGG | RAR | WEBP | MID |
| BMP | EOT | JPG | OTF | SVG | WOFF | PLS |
| BZ2 | EPS | JPEG | PDF | SVGZ | WOFF2 | TAR |
| CLASS | EXE | JS | PICT | SWF | XLS | XLSX |

* **Статусы кеша CloudFlare:**

* HIT          - Обслужен из кеша
* MISS         - Не было в кеше, получен с origin
* EXPIRED      - Был в кеше, но просрочен
* BYPASS       - Пропущен кеш (по правилам)
* DYNAMIC      - Динамический контент (не кешируется)

**Исключения и обходы:**
*   Если возвращаемый `Content-Type` — `application/octet-stream`, расширение не имеет значения, поскольку это обычно сигнал браузеру сохранить ресурс, а не отобразить его.
*   Cloudflare разрешает обслуживать `.jpg` как `image/webp` или `.gif` как `video/webm` и другие случаи, которые считаются маловероятными для атак.
*   [Обход Защиты от обмана кеша с использованием файла с расширением .avif — исправлено](https://hackerone.com/reports/1391635)

# URL

* [эксплуатации веб-кэша](https://portswigger.net/research/gotta-cache-em-all)
* [Web Cache Deception attacks cloudflare](https://developers.cloudflare.com/cache/cache-security/cache-deception-armor/)
