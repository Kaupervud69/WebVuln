> Атаки заголовка HTTP Host используют уязвимые веб-сайты, которые обрабатывают значение заголовка Host небезопасным способом. Если сервер неявно доверяет заголовку Host и не может должным образом проверить или экранировать его, полльзователь может использовать эти входные данные для внедрения вредоносных полезных нагрузок, которые манипулируют поведением на стороне сервера. 
>> Значение заголовка также может использоваться в различных взаимодействиях между различными системами инфраструктуры веб-сайта.

* [Как проверить уязвимости с помощью заголовка HTTP Host](#Как-проверить-уязвимости-с-помощью-заголовка-HTTP-Host)
	* [Произвольный заголовок Host](#Произвольный-заголовок-Host)
	* [Наличие некорректной проверки](#Наличие-некорректной-проверки)
	* [Отправка неоднозначных запросов](#Отправка-неоднозначных-запросов)
	* [Вставка заголовков переопределения хоста](#Вставка-заголовков-переопределения-хоста)
* [Атаки http host header](#Атаки-http-host-header)
	* [Отравление сброса пароля](#Отравление-сброса-пароля)
	* [Отравление веб-кэша через заголовок Host](#Отравление-веб-кэша-через-заголовок-Host)
	* [Использование классических уязвимостей на стороне сервера](#Использование-классических-уязвимостей-на-стороне-сервера)
	* [Доступ к ограниченной функциональности](#Доступ-к-ограниченной-функциональности)
	* [Доступ к внутренним веб-сайтам с помощью подбора виртуального хоста](#Доступ-к-внутренним-веб-сайтам-с-помощью-подбора-виртуального-хоста)
	* [SSRF на основе маршрутизации](#SSRF-на-основе-маршрутизации)
	* [Атаки на состояние соединения](#Атаки-на-состояние-соединения)
	* [SSRF через неправильно сформированную строку запроса](#SSRF-через-неправильно-сформированную-строку-запроса)
* [Защита](#Защита)

# Когда несколько приложений доступны по одному IP-адресу?

* **Виртуальный хостинг**
	* Один веб-сервер размещает несколько веб-сайтов или приложений.
* **Маршрутизация трафика через посредника**
	* Веб-сайты размещаются на отдельных внутренних серверах, но весь трафик между клиентом и серверами направляется через посредническую систему. 

# Как проверить уязвимости с помощью заголовка HTTP Host

## Произвольный заголовок Host

> Иногда возможне получить доступ к целевому веб-сайту, даже если предоставите неожиданный заголовок Host. 
Серверы иногда настраиваются с параметром по умолчанию или резервным вариантом на случай, если они получат запросы на доменные имена, которые они не распознают. Если целевой веб-сайт окажется сайтом по умолчанию, повезло.
>> Поскольку заголовок Host является такой фундаментальной частью работы веб-сайтов, его изменение часто означает, что невозможно связаться с целевым приложением. Фронтенд-сервер или балансировщик нагрузки, получивший ваш запрос, может просто не знать, куда его переслать, что приведет к ошибке «Недопустимый заголовок Host». Это особенно вероятно, если доступ к вашей цели осуществляется через CDN. 

## Наличие некорректной проверки

> Cледует попытаться понять, как веб-сайт анализирует заголовок Host. Иногда это может выявить лазейки, которые можно использовать для обхода проверки. 

* Указать нечисловой порт
```python
GET /example HTTP/1.1
Host: affected-website.com:bad-stuff-here
```
* Зарегистрировать произвольное доменное имя, заканчивающееся той же последовательностью символов, что и в белом списке
```python
GET /example HTTP/1.1
Host: notvulnerable-website.com
```
* Воспользоваться менее защищенным поддоменом, к которому ранее уже был получен доступ
```python
GET /example HTTP/1.1
Host: hacked-subdomain.vulnerable-website.com
```
* [Обход распространенных защит SSRF и ошибок анализа заголовков Origin](https://github.com/Kaupervud69/WebVuln/tree/main/SSRF)

## Отправка неоднозначных запросов

> Код, проверяющий хост, и код, который делает с ним что-то уязвимое, часто находятся в разных компонентах приложения или даже на разных серверах. Выявляя и эксплуатируя несоответствия в том, как они извлекают заголовок Host, вы можете выдать неоднозначный запрос, который, по-видимому, имеет другой хост в зависимости от того, какая система его просматривает.

* Внедрение дублирующих заголовков Host
```python
GET /example HTTP/1.1
Хост: affected-website.com
Хост: bad-stuff-here
```

* Абсолютный URL

> Официально строка запроса должна иметь приоритет при маршрутизации запроса, но на практике это не всегда так.
```python
GET https://vulnerable-website.com/ HTTP/1.1
Host: bad-stuff-here
```
> Может потребоваться поэкспериментировать с разными протоколами.

* Перенос строк

> Некоторые серверы будут интерпретировать отступленный заголовок как перенесенную строку и, следовательно, рассматривать его как часть значения предыдущего заголовка. Другие серверы вообще проигнорируют отступленный заголовок.
```python
GET /example HTTP/1.1
	Host: bad-stuff-here
Host: website.com
```

* Другие методы

Можно адаптировать множество методов [HTTP-smugling](https://github.com/Kaupervud69/WebVuln/tree/main/Request%20smuggling) для создания атак на заголовки Host.

## Вставка заголовков переопределения хоста

> Доступ к веб-сайтам часто осуществляется через какую-либо промежуточную систему, такую ​​как балансировщик нагрузки или обратный прокси-сервер. В такой архитектуре заголовок Host, который получает внутренний сервер, может содержать доменное имя одной из этих промежуточных систем. Обычно это не имеет значения для запрашиваемой функциональности.

>> Чтобы решить эту проблему, фронтенд может внедрить заголовок X-Forwarded-Host, содержащий исходное значение заголовка Host из первоначального запроса клиента. По этой причине, когда присутствует заголовок X-Forwarded-Host, многие фреймворки будут ссылаться на него вместо этого. 

* X-Forwarded-Host для внедрения вредоносного ввода, обходя любую проверку самого заголовка Host.
```python
GET /example HTTP/1.1
Host: affected-website.com
X-Forwarded-Host: bad-stuff-here
```
* Иные заголовками
```python
X-Host
X-Forwarded-Server
X-HTTP-Host-Override
Forwarded
```

> С точки зрения безопасности важно отметить, что некоторые веб-сайты поддерживают такое поведение непреднамеренно. Обычно это происходит потому, что один или несколько из этих заголовков включены по умолчанию в какой-то сторонней технологии, которую они используют.

# Атаки http host header

## Отравление сброса пароля

> **Отравление сброса пароля** — это метод, при котором пользователь манипулирует уязвимым веб-сайтом, чтобы создать ссылку для сброса пароля, указывающую на домен, находящийся под его контролем. Это поведение может быть использовано для кражи секретных токенов, необходимых для сброса паролей произвольных пользователей, и, в конечном итоге, для компрометации их учетных записей.

* **Как работает сброс пароля?**

* Один из наиболее распространенных подходов выглядит примерно так:
	* Пользователь вводит свое имя пользователя или адрес электронной почты и отправляет запрос на сброс пароля.
	* Веб-сайт проверяет, существует ли этот пользователь, а затем генерирует временный, уникальный, высокоэнтропийный токен, который он связывает с учетной записью пользователя на бэкэнде.
	* Веб-сайт отправляет пользователю электронное письмо, содержащее ссылку для сброса пароля. Уникальный токен сброса пользователя включен в качестве параметра запроса в соответствующий URL-адрес: ```https://normal-website.com/reset?token=0a1b2c3d4e5f6g7h8i9j```
	* При посещении этого URL-адрес, веб-сайт проверяет, является ли предоставленный токен действительным, и использует его для определения того, какая учетная запись сбрасывается. Если все так, как ожидалось, пользователю предоставляется возможность ввести новый пароль. 
	* Токен уничтожается.

* **Как построить атаку отравления сброса пароля**

* Если URL-адрес, отправляемый пользователю, динамически генерируется на основе контролируемого ввода, такого как заголовок Host.
	* Пользователь получает адрес электронной почты или имя пользователя жертвы, если требуется, и отправляет запрос на сброс пароля от ее имени.
	* При отправке формы он перехватывает полученный HTTP-запрос и изменяет заголовок Host так, чтобы он указывал на домен, который он контролирует.

> Жертва получает настоящее электронное письмо для сброса пароля непосредственно с веб-сайта. Похоже, оно содержит обычную ссылку для сброса пароля и, что особенно важно, содержит действительный токен сброса пароля, связанный с ее учетной записью. Однако доменное имя в URL-адресе указывает на контролируемый нами сервер.
```https://evil-user.net/reset?token=0a1b2c3d4e5f6g7h8i9j```

* Если жертва нажмет на эту ссылку (или она будет извлечена каким-либо другим способом, например, антивирусным сканером), токен сброса пароля будет доставлен на наш сервер.

> В реальной атаке злоумышленник может попытаться увеличить вероятность того, что жертва нажмет на ссылку, предварительно подогрев ее, например, с помощью поддельного уведомления о взломе.

Даже если не возможно контролировать ссылку сброса пароля, иногда можно использовать заголовок Host для внедрения HTML в конфиденциальные электронные письма.(почтовые клиенты обычно не выполняют JavaScript, но другие методы внедрения HTML-кода, такие как [dangling markup attacks!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!](!!!!!!!!!!!!!!!!!!!!!!!!!!!!!) , по-прежнему могут применяться.

## Отравление веб-кэша через заголовок Host

* При проверке потенциальных атак заголовка Host возникает уязвимым поведением, которое нельзя эксплуатировать напрямую. 
	* Отраженные уязвимости на стороне клиента, такие как XSS, обычно не могут быть использованы, если они вызваны заголовком Host. У пользователя нет возможности заставить браузер жертвы выдать неправильный хост полезным образом.

> Однако, если цель использует веб-кэш, возможно, можно превратить эту бесполезную, отраженную уязвимость в опасную, сохраненную, убедив кэш предоставить отравленный ответ другим пользователям.

* Нужно получить ответ от сервера, который отражает внедренную полезную нагрузку. Задача состоит в том, чтобы сделать это, сохранив ключ кэша, который по-прежнему будет сопоставлен с запросами других пользователей.
* В случае успеха следующим шагом будет кэширование этого вредоносного ответа.
* Затем он будет предоставлен всем пользователям, которые попытаются посетить затронутую страницу.

Автономные кэши обычно включают заголовок Host в ключ кэша, поэтому этот подход обычно лучше всего работает в интегрированных кэшах уровня приложения. Тем не менее, методы, обсуждавшиеся ранее, иногда позволяют отравить даже автономные веб-кэши.

## Использование классических уязвимостей на стороне сервера

> Каждый заголовок HTTP является потенциальным вектором для использования классических уязвимостей на стороне сервера, и заголовок Host не является исключением. Например, следует попробовать обычные методы зондирования SQL-инъекций через заголовок Host. Если значение заголовка передается в оператор SQL, это может быть использовано.

## Доступ к ограниченной функциональности

> Веб-сайты часто ограничивают доступ к определенным функциям только для внутренних пользователей. Функции контроля доступа некоторых веб-сайтов делают ошибочные предположения, которые позволяют обойти эти ограничения, внеся простые изменения в заголовок Host. Это может открыть увеличенную поверхность атаки для других эксплойтов.
```В Burp Repeater измени заголовок Host на localhost и отправьте запрос.```

## Доступ к внутренним веб-сайтам с помощью подбора виртуального хоста

* Иногда компании совершают ошибку, размещая общедоступные веб-сайты и частные внутренние сайты на одном сервере. Обычно серверы имеют как публичный, так и частный IP-адрес. Поскольку внутреннее имя хоста может разрешаться в частный IP-адрес, этот сценарий не всегда можно обнаружить, просто посмотрев на записи DNS:
```
www.example.com: 12.34.56.78
intranet.example.com: 10.0.0.132
```
> В некоторых случаях внутренний сайт может даже не иметь связанной с ним публичной записи DNS. Тем не менее, пользователь обычно может получить доступ к любому виртуальному хосту на любом сервере, к которому у него есть доступ, при условии, что он ```может угадать имена хостов```. 

* Обнаружить скрытое доменное имя другими способами
	* Раскрытие информации
	* Burp Intruder, для подбора виртуальных хостов

## SSRF на основе маршрутизации

Иногда возможно использовать заголовок Host для запуска мощных атак [SSRF на основе маршрутизации](https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface). 

> Классические уязвимости SSRF обычно основаны на XXE или эксплуатируемой бизнес-логике, которая отправляет HTTP-запросы на URL-адрес, полученный из контролируемого пользователем ввода.

* SSRF на основе маршрутизации, полагается на эксплуатацию промежуточных компонентов, которые распространены во многих облачных архитектурах. 
	* внутренние балансировщики нагрузки
	* обратные прокси-серверы.
 
Они находятся в привилегированном сетевом положении, что позволяет им получать запросы напрямую из публичной сети, а также иметь доступ к большей части, если не ко всей, внутренней сети. Это делает заголовок Host мощным вектором для атак SSRF, потенциально превращая простой балансировщик нагрузки в шлюз для всей внутренней сети.

Для выявления этих уязвимостей можно использовать Burp Collaborator или его аналоги. 

## Атаки на состояние соединения

Из соображений производительности многие веб-сайты повторно используют соединения для нескольких циклов запроса/ответа с одним и тем же клиентом. Плохо реализованные HTTP-серверы иногда работают на опасном предположении, что определенные свойства, такие как заголовок Host, идентичны для всех запросов HTTP/1.1, отправленных по одному и тому же соединению. 

> Некоторые серверы, выполняют тщательную проверку только для первого запроса, который они получают по новому соединению. В этом случае можно потенциально обойти эту проверку, отправив невинно выглядящий начальный запрос, а затем свой вредоносный запрос по тому же соединению.

>> Многие обратные прокси используют заголовок Host для маршрутизации запросов на правильный бэкэнд. Если они предполагают, что все запросы в соединении предназначены для того же хоста, что и начальный запрос, это может предоставить полезный вектор для ряда атак на заголовок Host, включая SSRF на основе маршрутизации, отравление сброса пароля и отравление кэша.
```
* Send group in sequence (single connection).
* Change the Connection header to keep-alive.
```
## SSRF через неправильно сформированную строку запроса

> Пользовательские прокси иногда не могут правильно проверить строку запроса, что может позволить вам предоставить необычный, неправильно сформированный ввод с неудачными результатами.

Например, обратный прокси может взять путь из строки запроса, добавить к нему префикс ```http://backend-server``` и направить запрос на этот URL-адрес восходящего потока. Это работает нормально, если путь начинается с символа /.
```GET @private-intranet/example HTTP/1.1```

Результирующий URL-адрес восходящего потока будет ```http://backend-server@private-intranet/example```, что большинство библиотек HTTP интерпретируют как запрос на доступ к private-intranet с именем пользователя backend-server.


# Защита

* **Защита абсолютных URL**
Когда нужно использовать абсолютные URL, следует потребовать, чтобы текущий домен был вручную указан в файле конфигурации, и ссылаться на это значение вместо заголовка Host. Такой подход устранит угрозу отравления сброса пароля.
* **Проверка заголовка Host**
Это должно включать проверку его по белому списку разрешенных доменов и отклонение или перенаправление любых запросов на нераспознанные хосты. Следует обратиться к документации фреймворка за руководством о том, как это сделать. Например, фреймворк Django предоставляет параметр ALLOWED_HOSTS в файле настроек. Такой подход снизит подверженность атакам с внедрением заголовков хоста.
* **Не поддерживать заголовки переопределения хоста**
Не поддерживать дополнительные заголовки, которые могут использоваться для создания этих атак, в частности X-Forwarded-Host.
* **Белый список разрешенных доменов**
Чтобы предотвратить атаки на внутреннюю инфраструктуру на основе маршрутизации, следует настроить балансировщик нагрузки или любые обратные прокси-серверы для пересылки запросов только в белый список разрешенных доменов.
* **Виртуальные хосты только для внутренних целей**
При использовании виртуального хостинга следует избегать размещения веб-сайтов и приложений только для внутренних целей на том же сервере, что и общедоступный контент.
