> Атаки заголовка HTTP Host используют уязвимые веб-сайты, которые обрабатывают значение заголовка Host небезопасным способом. Если сервер неявно доверяет заголовку Host и не может должным образом проверить или экранировать его, полльзователь может использовать эти входные данные для внедрения вредоносных полезных нагрузок, которые манипулируют поведением на стороне сервера. 
>> Значение заголовка также может использоваться в различных взаимодействиях между различными системами инфраструктуры веб-сайта.

# Когда несколько приложений доступны по одному IP-адресу?

* **Виртуальный хостинг**
	* Один веб-сервер размещает несколько веб-сайтов или приложений.
* **Маршрутизация трафика через посредника**
	* Веб-сайты размещаются на отдельных внутренних серверах, но весь трафик между клиентом и серверами направляется через посредническую систему. 

# Как проверить уязвимости с помощью заголовка HTTP Host

## Произвольный заголовок Host

> Иногда возможне получить доступ к целевому веб-сайту, даже если предоставите неожиданный заголовок Host. 
Серверы иногда настраиваются с параметром по умолчанию или резервным вариантом на случай, если они получат запросы на доменные имена, которые они не распознают. Если целевой веб-сайт окажется сайтом по умолчанию, повезло.
>> Поскольку заголовок Host является такой фундаментальной частью работы веб-сайтов, его изменение часто означает, что невозможно связаться с целевым приложением. Фронтенд-сервер или балансировщик нагрузки, получивший ваш запрос, может просто не знать, куда его переслать, что приведет к ошибке «Недопустимый заголовок Host». Это особенно вероятно, если доступ к вашей цели осуществляется через CDN. 

## Наличие некорректной проверки

> Cледует попытаться понять, как веб-сайт анализирует заголовок Host. Иногда это может выявить лазейки, которые можно использовать для обхода проверки. 

* Указать нечисловой порт
```python
GET /example HTTP/1.1
Host: affected-website.com:bad-stuff-here
```
* Зарегистрировать произвольное доменное имя, заканчивающееся той же последовательностью символов, что и в белом списке
```python
GET /example HTTP/1.1
Host: notvulnerable-website.com
```
* Воспользоваться менее защищенным поддоменом, к которому ранее уже был получен доступ
```python
GET /example HTTP/1.1
Host: hacked-subdomain.vulnerable-website.com
```
* [Обход распространенных защит SSRF и ошибок анализа заголовков Origin](https://github.com/Kaupervud69/WebVuln/tree/main/SSRF)

## Отправка неоднозначных запросов

> Код, проверяющий хост, и код, который делает с ним что-то уязвимое, часто находятся в разных компонентах приложения или даже на разных серверах. Выявляя и эксплуатируя несоответствия в том, как они извлекают заголовок Host, вы можете выдать неоднозначный запрос, который, по-видимому, имеет другой хост в зависимости от того, какая система его просматривает.

* Внедрение дублирующих заголовков Host
```python
GET /example HTTP/1.1
Хост: affected-website.com
Хост: bad-stuff-here
```

* Абсолютный URL

> Официально строка запроса должна иметь приоритет при маршрутизации запроса, но на практике это не всегда так.
```python
GET https://vulnerable-website.com/ HTTP/1.1
Host: bad-stuff-here
```
> Может потребоваться поэкспериментировать с разными протоколами.

* Перенос строк

> Некоторые серверы будут интерпретировать отступленный заголовок как перенесенную строку и, следовательно, рассматривать его как часть значения предыдущего заголовка. Другие серверы вообще проигнорируют отступленный заголовок.
```python
GET /example HTTP/1.1
	Host: bad-stuff-here
Host: website.com
```

* Другие методы

Можно адаптировать множество методов [HTTP-smugling](https://github.com/Kaupervud69/WebVuln/tree/main/Request%20smuggling) для создания атак на заголовки Host.

## Вставка заголовков переопределения хоста

> Доступ к веб-сайтам часто осуществляется через какую-либо промежуточную систему, такую ​​как балансировщик нагрузки или обратный прокси-сервер. В такой архитектуре заголовок Host, который получает внутренний сервер, может содержать доменное имя одной из этих промежуточных систем. Обычно это не имеет значения для запрашиваемой функциональности.

>> Чтобы решить эту проблему, фронтенд может внедрить заголовок X-Forwarded-Host, содержащий исходное значение заголовка Host из первоначального запроса клиента. По этой причине, когда присутствует заголовок X-Forwarded-Host, многие фреймворки будут ссылаться на него вместо этого. 

* X-Forwarded-Host для внедрения вредоносного ввода, обходя любую проверку самого заголовка Host.
```python
GET /example HTTP/1.1
Host: affected-website.com
X-Forwarded-Host: bad-stuff-here
```
* Иные заголовками
```python
X-Host
X-Forwarded-Server
X-HTTP-Host-Override
Forwarded
```

> С точки зрения безопасности важно отметить, что некоторые веб-сайты поддерживают такое поведение непреднамеренно. Обычно это происходит потому, что один или несколько из этих заголовков включены по умолчанию в какой-то сторонней технологии, которую они используют.

# Атаки http host header

## Отравление сброса пароля

> **Отравление сброса пароля** — это метод, при котором пользователь манипулирует уязвимым веб-сайтом, чтобы создать ссылку для сброса пароля, указывающую на домен, находящийся под его контролем. Это поведение может быть использовано для кражи секретных токенов, необходимых для сброса паролей произвольных пользователей, и, в конечном итоге, для компрометации их учетных записей.

* **Как работает сброс пароля?**

* Один из наиболее распространенных подходов выглядит примерно так:
	* Пользователь вводит свое имя пользователя или адрес электронной почты и отправляет запрос на сброс пароля.
	* Веб-сайт проверяет, существует ли этот пользователь, а затем генерирует временный, уникальный, высокоэнтропийный токен, который он связывает с учетной записью пользователя на бэкэнде.
	* Веб-сайт отправляет пользователю электронное письмо, содержащее ссылку для сброса пароля. Уникальный токен сброса пользователя включен в качестве параметра запроса в соответствующий URL-адрес: ```https://normal-website.com/reset?token=0a1b2c3d4e5f6g7h8i9j```
	* При посещении этого URL-адрес, веб-сайт проверяет, является ли предоставленный токен действительным, и использует его для определения того, какая учетная запись сбрасывается. Если все так, как ожидалось, пользователю предоставляется возможность ввести новый пароль. 
	* Токен уничтожается.

* **Как построить атаку отравления сброса пароля**

* Если URL-адрес, отправляемый пользователю, динамически генерируется на основе контролируемого ввода, такого как заголовок Host.
	* Пользователь получает адрес электронной почты или имя пользователя жертвы, если требуется, и отправляет запрос на сброс пароля от ее имени.
	* При отправке формы он перехватывает полученный HTTP-запрос и изменяет заголовок Host так, чтобы он указывал на домен, который он контролирует.

> Жертва получает настоящее электронное письмо для сброса пароля непосредственно с веб-сайта. Похоже, оно содержит обычную ссылку для сброса пароля и, что особенно важно, содержит действительный токен сброса пароля, связанный с ее учетной записью. Однако доменное имя в URL-адресе указывает на контролируемый нами сервер.
```https://evil-user.net/reset?token=0a1b2c3d4e5f6g7h8i9j```

* Если жертва нажмет на эту ссылку (или она будет извлечена каким-либо другим способом, например, антивирусным сканером), токен сброса пароля будет доставлен на наш сервер.

> В реальной атаке злоумышленник может попытаться увеличить вероятность того, что жертва нажмет на ссылку, предварительно подогрев ее, например, с помощью поддельного уведомления о взломе.

Даже если не возможно контролировать ссылку сброса пароля, иногда можно использовать заголовок Host для внедрения HTML в конфиденциальные электронные письма.(почтовые клиенты обычно не выполняют JavaScript, но другие методы внедрения HTML-кода, такие как [dangling markup attacks!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!](!!!!!!!!!!!!!!!!!!!!!!!!!!!!!) , по-прежнему могут применяться.

## Отравление веб-кэша через заголовок Host

* При проверке потенциальных атак заголовка Host возникает уязвимым поведением, которое нельзя эксплуатировать напрямую. 
	* Отраженные уязвимости на стороне клиента, такие как XSS, обычно не могут быть использованы, если они вызваны заголовком Host. У пользователя нет возможности заставить браузер жертвы выдать неправильный хост полезным образом.

> Однако, если цель использует веб-кэш, возможно, можно превратить эту бесполезную, отраженную уязвимость в опасную, сохраненную, убедив кэш предоставить отравленный ответ другим пользователям.

* Нужно получить ответ от сервера, который отражает внедренную полезную нагрузку. Задача состоит в том, чтобы сделать это, сохранив ключ кэша, который по-прежнему будет сопоставлен с запросами других пользователей.
* В случае успеха следующим шагом будет кэширование этого вредоносного ответа.
* Затем он будет предоставлен всем пользователям, которые попытаются посетить затронутую страницу.

Автономные кэши обычно включают заголовок Host в ключ кэша, поэтому этот подход обычно лучше всего работает в интегрированных кэшах уровня приложения. Тем не менее, методы, обсуждавшиеся ранее, иногда позволяют отравить даже автономные веб-кэши.

* **Использование классических уязвимостей на стороне сервера**

Каждый заголовок HTTP является потенциальным вектором для использования классических уязвимостей на стороне сервера, и заголовок Host не является исключением. Например, вам следует попробовать обычные методы зондирования SQL-инъекций через заголовок Host. Если значение заголовка передается в оператор SQL, это может быть использовано.

* **Доступ к ограниченной функциональности**

По довольно очевидным причинам веб-сайты часто ограничивают доступ к определенным функциям только для внутренних пользователей. Однако функции контроля доступа некоторых веб-сайтов делают ошибочные предположения, которые позволяют вам обойти эти ограничения, внеся простые изменения в заголовок Host. Это может открыть увеличенную поверхность атаки для других эксплойтов.

* **Доступ к внутренним веб-сайтам с помощью подбора виртуального хоста**

Иногда компании совершают ошибку, размещая общедоступные веб-сайты и частные внутренние сайты на одном сервере. Обычно серверы имеют как публичный, так и частный IP-адрес. Поскольку внутреннее имя хоста может разрешаться в частный IP-адрес, этот сценарий не всегда можно обнаружить, просто посмотрев на записи DNS:
www.example.com: 12.34.56.78
intranet.example.com: 10.0.0.132

В некоторых случаях внутренний сайт может даже не иметь связанной с ним публичной записи DNS. Тем не менее, злоумышленник обычно может получить доступ к любому виртуальному хосту на любом сервере, к которому у него есть доступ, при условии, что он может угадать имена хостов. Если они обнаружили скрытое доменное имя другими способами, такими как раскрытие информации, они могут просто запросить его напрямую. В противном случае они могут использовать такие инструменты, как Burp Intruder, для подбора виртуальных хостов с помощью простого списка слов кандидатов на поддомены.

* **SSRF на основе маршрутизации**

Иногда также возможно использовать заголовок Host для запуска мощных атак SSRF на основе маршрутизации. Иногда их называют «атаками SSRF на заголовок хоста», и они были подробно изучены PortSwigger Research в Cracking the lens: targeting HTTP's hidden attack-surface.

Классические уязвимости SSRF обычно основаны на XXE или эксплуатируемой бизнес-логике, которая отправляет HTTP-запросы на URL-адрес, полученный из контролируемого пользователем ввода. SSRF на основе маршрутизации, с другой стороны, полагается на эксплуатацию промежуточных компонентов, которые распространены во многих облачных архитектурах. Сюда входят внутренние балансировщики нагрузки и обратные прокси-серверы.

Хотя эти компоненты развертываются для разных целей, по сути, они получают запросы и пересылают их на соответствующий бэкэнд. Если они небезопасно настроены для пересылки запросов на основе непроверенного заголовка хоста, их можно заставить неправильно маршрутизировать запросы в произвольную систему по выбору злоумышленника.

Эти системы представляют собой фантастические цели. Они находятся в привилегированном сетевом положении, что позволяет им получать запросы напрямую из публичной сети, а также иметь доступ к большей части, если не ко всей, внутренней сети. Это делает заголовок Host мощным вектором для атак SSRF, потенциально превращая простой балансировщик нагрузки в шлюз для всей внутренней сети.

Вы можете использовать Burp Collaborator для выявления этих уязвимостей. Если вы указываете домен вашего сервера Collaborator в заголовке Host и впоследствии получаете DNS-поиск от целевого сервера или другой системы в пути, это означает, что вы можете направлять запросы в произвольные домены.

Убедившись, что вы можете успешно манипулировать промежуточной системой для направления ваших запросов на произвольный публичный сервер, следующим шагом будет проверка того, можете ли вы использовать это поведение для доступа к системам, предназначенным только для внутренних целей. Для этого вам нужно будет определить частные IP-адреса, которые используются во внутренней сети цели. В дополнение к любым IP-адресам, которые раскрываются приложением, вы также можете сканировать имена хостов, принадлежащие компании, чтобы увидеть, разрешаются ли какие-либо из них в частный IP-адрес. Если все остальное не помогает, вы все равно можете определить действительные IP-адреса, просто перебрав стандартные частные диапазоны IP-адресов, например, 192.168.0.0/16.

[Обозначение CIDR]

Диапазоны IP-адресов обычно выражаются с помощью обозначения CIDR, например, 192.168.0.0/16.

Адреса IPv4 состоят из четырех 8-битных десятичных значений, известных как «октеты», каждое из которых разделено точкой. Значение каждого октета может находиться в диапазоне от 0 до 255, что означает, что минимальный возможный адрес IPv4 будет 0.0.0.0, а максимальный — 255.255.255.255.

В нотации CIDR наименьший IP-адрес в диапазоне записывается явно, за ним следует другое число, которое указывает, сколько бит от начала данного адреса зафиксировано для всего диапазона. Например, 10.0.0.0/8 указывает, что первые 8 бит зафиксированы (первый октет). Другими словами, этот диапазон включает все IP-адреса от 10.0.0.0 до 10.255.255.255.


* **Атаки на состояние соединения**

Из соображений производительности многие веб-сайты повторно используют соединения для нескольких циклов запроса/ответа с одним и тем же клиентом. Плохо реализованные HTTP-серверы иногда работают на опасном предположении, что определенные свойства, такие как заголовок Host, идентичны для всех запросов HTTP/1.1, отправленных по одному и тому же соединению. Это может быть верно для запросов, отправленных браузером, но не обязательно для последовательности запросов, отправленных Burp Repeater. Это может привести к ряду потенциальных проблем.

Например, вы можете иногда сталкиваться с серверами, которые выполняют тщательную проверку только для первого запроса, который они получают по новому соединению. В этом случае вы можете потенциально обойти эту проверку, отправив невинно выглядящий начальный запрос, а затем свой вредоносный запрос по тому же соединению.

Многие обратные прокси используют заголовок Host для маршрутизации запросов на правильный бэкэнд. Если они предполагают, что все запросы в соединении предназначены для того же хоста, что и начальный запрос, это может предоставить полезный вектор для ряда атак на заголовок Host, включая SSRF на основе маршрутизации, отравление сброса пароля и отравление кэша.

* **SSRF через неправильно сформированную строку запроса**

Пользовательские прокси иногда не могут правильно проверить строку запроса, что может позволить вам предоставить необычный, неправильно сформированный ввод с неудачными результатами.

Например, обратный прокси может взять путь из строки запроса, добавить к нему префикс http://backend-server и направить запрос на этот URL-адрес восходящего потока. Это работает нормально, если путь начинается с символа /, но что, если вместо этого он начинается с символа @?
GET @private-intranet/example HTTP/1.1

Результирующий URL-адрес восходящего потока будет http://backend-server@private-intranet/example, что большинство библиотек HTTP интерпретируют как запрос на доступ к private-intranet с именем пользователя backend-server.







* **Профит**
Поскольку заголовок Host фактически контролируется пользователем, эта практика может привести к ряду проблем. Если входные данные не экранированы или не проверены должным образом, заголовок Host является потенциальным вектором для эксплуатации ряда других уязвимостей, в частности:
* Отравление веб-кэша
* Ошибки бизнес-логики в определенных функциях
* SSRF на основе маршрутизации
* Классические уязвимости на стороне сервера, такие как SQL-инъекция
* Отравление сброса пароля

* **Защита**
* Защита абсолютных URL
Когда вам нужно использовать абсолютные URL, вам следует потребовать, чтобы текущий домен был вручную указан в файле конфигурации, и ссылаться на это значение вместо заголовка Host. Такой подход устранит угрозу отравления сброса пароля, например.
* Проверка заголовка Host
Если вам необходимо использовать заголовок Host, убедитесь, что вы правильно его проверяете. Это должно включать проверку его по белому списку разрешенных доменов и отклонение или перенаправление любых запросов на нераспознанные хосты. Вам следует обратиться к документации вашего фреймворка за руководством о том, как это сделать. Например, фреймворк Django предоставляет параметр ALLOWED_HOSTS в файле настроек. Такой подход снизит вашу подверженность атакам с внедрением заголовков хоста.
* Не поддерживайте заголовки переопределения хоста
Также важно проверить, что вы не поддерживаете дополнительные заголовки, которые могут использоваться для создания этих атак, в частности X-Forwarded-Host. Помните, что они могут поддерживаться по умолчанию.
* Белый список разрешенных доменов
Чтобы предотвратить атаки на внутреннюю инфраструктуру на основе маршрутизации, вам следует настроить балансировщик нагрузки или любые обратные прокси-серверы для пересылки запросов только в белый список разрешенных доменов.
* Будьте осторожны с виртуальными хостами только для внутренних целей
При использовании виртуального хостинга вам следует избегать размещения веб-сайтов и приложений только для внутренних целей на том же сервере, что и общедоступный контент. В противном случае злоумышленники смогут получить доступ к внутренним доменам с помощью манипуляции заголовками хоста.
