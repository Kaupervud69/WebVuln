### **RACE CONDITION**

* **Описание**
* 	Race Condition (англ. «состояние гонки», на профессиональном жаргоне — просто «рейса́» или «рейсы́») — тип уязвимости, когда два или более процесса или потока конкурируют за доступ к общему ресурсу. Это может привести к непредсказуемым результатам, таким как неправильные данные, сбои в программе или даже потеря данных.
Race Condition возникает из-за параллельного выполнения кода, когда не учитывается порядок операций или не предусмотрены механизмы синхронизации доступа к общим ресурсам.

* **Виды**
* 	Обход лимитов.   (repeater, turbointruder)
		Многократное погашение подарочной карты
* 	Скрытые многошаговые последовательности.   (прогреть соединение) 
		Обход mfa
* 	Race Condition в нескольких точках.   
		Добавление товара в чек после оплаты
* 	Race Condition в одной точке.
		Самая хорошая цель для этого типа уязвимости — подтверждение адресов электронной почты.
*	Состояния гонки частичного построения
		Многие приложения создают объекты в несколько этапов, что может ввести временное промежуточное состояние, в котором объект может быть использован.
*	Атаки, чувствительные к времени*
		использование временных меток высокого разрешения вместо криптографически защищенных случайных строк для генерации токенов безопасности.

* **Точки входа**
*	Определить одноразовую или ограниченную по скорости конечную точку, которая имеет какое-либо влияние на безопасность или другую полезную цель.
*	Выполнить несколько запросов к этой конечной точке в быстрой последовательности, чтобы посмотреть, сможете ли вы превысить этот лимит.

* **POC**
*	Прогнозирование
	Является ли безопасность этой конечной точки критической?
	Есть ли потенциальная возможность столкновения?
*	Исследование 
	сначала нужно протестировать поведение конечной точки в обычных условиях.
	Затем отправьте одну и ту же группу запросов одновременно
	ищите какую-то форму отклонения от того, что вы наблюдали во время бенчмаркинга. Это включает изменение одного или нескольких ответов, но не забывайте о вторичных эффектах, таких как разное содержимое электронной почты или видимое изменение поведения приложения после этого.
*	Доказательство
	Попытайтесь понять, что происходит, удалите лишние запросы и убедитесь, что вы все еще можете воспроизвести эффекты.
	
* **Repeater**
   Send group in sequence (single connection) - Отправить группу последовательно (одно подключение), Repeater установит соединение с целью, отправит запросы со всех вкладок в группе, а затем закроет соединение.
   	Это полезно для атак на основе синхронизации, которые полагаются на возможность сравнивать ответы с очень небольшими различиями во времени.
   Send group in sequence (separate connections) - Отправить группу последовательно (отдельные соединения), Repeater устанавливает соединение с целью, отправляет запрос с первой вкладки, а затем закрывает соединение. Он 							повторяет этот процесс для всех остальных вкладок в том порядке, в котором они расположены в группе.
   Send group in parallel -  Repeater синхронизирует параллельные запросы, чтобы гарантировать, что все они прибудут полностью одновременно. Он использует различные методы синхронизации в зависимости от используемой версии HTTP.
*	используя атаку с одним пакетом (или синхронизацию последнего байта, если HTTP/2 не поддерживается)

* **Профит**
*	Многократное погашение подарочной карты
*	Многократная оценка продукта
*	Снятие или перевод наличных сверх баланса вашего счета
*	Повторное использование одного решения CAPTCHA
*	Обход ограничения скорости перебора
*	Добавление товара в чек после оплаты
*	перехвата сессий, сброса пароля и других атак, связанных с конкурентным доступом к ресурсам. 

* **Защита**
*    Не допускать смешивания данных из разных хранилищ и баз данных. Это снизит вероятность рассогласованности данных и, как следствие, уязвимостей, связанных с многопоточной обработкой.
*    Использовать механизмы синхронизации, такие как блокировки (mutex), семафоры, условные переменные и т. д. Это предотвратит одновременный доступ к общим ресурсам из разных потоков. А ещё эти механизмы обеспечат корректную последовательность операций при доступе к общим ресурсам, гарантируя, что изменения данных выполняются безопасно и последовательно.
*    Обеспечивать атомарность состояния критичных конечных точек. Здесь помогут функции параллелизма хранилища данных. Например, для проверки соответствия суммы оплаты в корзине и подтверждения заказа необходимо использовать одну транзакцию базы данных. Это предотвратит частичное выполнение операций и гарантирует целостность данных в случае ошибки.
*    Использовать возможности целостности и согласованности хранилища данных. Например, ограничения уникальности столбцов. Эти механизмы защитят от ситуаций, когда несколько потоков могут записать конфликтующие данные, нарушая согласованность хранилища.
*    Не использовать один уровень хранения данных для защиты другого. Например, сеансы не подходят для предотвращения атак на превышение лимитов в базах данных.
*    Проверять систему обработки сеансов на предмет поддержки внутренней согласованности сеансов. Это предотвратит возможные конфликты между сессиями и снизит вероятность атак, связанных с нарушением целостности данных.
*    Избегать глобальных переменных и отдавать предпочтение локальным данным, которые не могут быть изменены несколькими потоками одновременно. Это снизит вероятность возникновения Race Condition и улучшит безопасность приложения.


* **Обход защиты**
* При тестировании условий гонки нескольких конечных точек вы можете столкнуться с проблемами при попытке выровнять окна гонки для каждого запроса, даже если вы отправляете их все одновременно с помощью однопакетной техники.
	Эта распространенная проблема в основном вызвана следующими двумя факторами:

	Задержки, вносимые сетевой архитектурой. Например, может возникнуть задержка, когда сервер front-end устанавливает новое соединение с back-end. Используемый протокол также может иметь большое влияние.
	Задержки, вызванные обработкой, специфичной для конечной точки. Различные конечные точки изначально различаются по времени обработки, иногда значительно, в зависимости от того, какие операции они запускают.
*	Злоупотребление ограничениями скорости или ресурсов
Веб-серверы часто задерживают обработку запросов, если их слишком много отправляется слишком быстро. Отправляя большое количество фиктивных запросов, чтобы намеренно вызвать ограничение скорости или ресурсов, вы можете вызвать подходящую задержку на стороне сервера. Это делает атаку с одним пакетом жизнеспособной, даже когда требуется отложенное выполнение.
*	Разогрев соединения**
Если вы по-прежнему видите непоследовательное время отклика на одной конечной точке, даже при использовании техники с одним пакетом, это признак того, что задержка на стороне сервера мешает вашей атаке. Вы можете обойти это, используя Turbo Intruder для отправки некоторых запросов на разогрев соединения перед тем, как продолжить с вашими основными запросами на атаку.

Задержки внутреннего соединения обычно не мешают атакам состояния гонки, поскольку они обычно задерживают параллельные запросы одинаково, поэтому запросы остаются синхронизированными.

Важно уметь отличать эти задержки от задержек, вызванных факторами, специфичными для конечной точки. 
*	Если вы заметили, что все ваши запросы обрабатываются последовательно, попробуйте отправить каждый из них с использованием другого токена сеанса.
*	POST /confirm?token[]=

