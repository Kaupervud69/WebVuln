* [Тестирование](#Тестирование)
* [В строке запроса](#Строка)
* [В путях REST](#REST)
* [Структурированные форматы данных](#Структурированные)

  
# Загрязнение параметров API на стороне сервера (HTTP Parameter Pollution)

> Некоторые системы содержат внутренние API, которые не доступны напрямую из Интернета. Загрязнение параметров на стороне сервера происходит, когда веб-сайт встраивает пользовательский ввод в запрос на стороне сервера к внутреннему API без адекватного кодирования. 

* **Точки входа**
  
  * Параметры запроса
  * Поля формы
  * Заголовки 
  * Параметры пути URL

# Тестирование

## Строка запроса:

         #, & и =, добавить во входные данные и понаблюдайте за реакцией приложения.
 	
  * Усечение строк запроса

        GET /users/search?name=user#foo&publicProfile=true
    
    > Необходимо закодировать символ # в URL. В противном случае приложение фронтенда будет интерпретировать его как идентификатор фрагмента и не будет передано во внутренний API.

  * Внедрение недопустимых параметров

        GET /userSearch?name=user%26foo=xyz&back=/home
    > если ответ не изменился, это может означать, что параметр был успешно внедрен, но проигнорирован приложением.
    
  * Внедрение допустимых параметров
    
      > Например, если вы определили параметр email, вы можете добавить его в строку запроса следующим образом:

        GET /userSearch?name=user%26email=foo&back=/home

  * Переопределение существующих параметров

        GET /userSearch?name=user%26name=admins&back=/home

      > PHP анализирует только последний параметр. Это приведет к поиску пользователем admin.
      > 
      > ASP.NET объединяет оба параметра. Это приведет к поиску пользователя по запросу user,admin что может привести к сообщению об ошибке Invalid username.
      > 
      > Node.js / express анализирует только первый параметр. Это приведет к поиску пользователя по слову user, что даст неизменный результат.

## REST

RESTful API может размещать имена и значения параметров в пути URL, а не в строке запроса.

    /api/users/123

* /api — это корневая конечная точка API.
* /users представляет ресурс, в данном случае пользователи.
* /123 представляет параметр, здесь идентификатор конкретного пользователя.

> Запросы отправляются на следующую конечную точку:
> GET /edit_profile.php?name=123
>
> Это приводит к следующему запросу на стороне сервера:
> GET /api/private/users/123

    %2f..%2f - последовательности обхода пути для изменения параметров и понаблюдайте, как реагирует приложение.
    param%23
    param%3F
    ./param
    ../param%23
    ../../../%23

Not found. Это означает, что вы вышли за пределы корня API.
    
    username=../../../../openapi.json%23 (swagger.json, openapi.yaml, api-docs.json, apidoc.json, schema.json, docs)

## Структурированные форматы данных:

POST /myaccount
{"name": "peter\",\"access_level\":\"administrator"}
PATCH /users/7312/update
{"name":"peter","access_level":"administrator"}
В ответах также может происходить внедрение структурированного формата. Например, это может произойти, если пользовательский ввод надежно хранится в базе данных, а затем встроен в ответ JSON из внутреннего API без адекватного кодирования. Обычно вы можете обнаружить и использовать внедрение структурированного формата в ответах так же, как и в запросах.

* **Профит**
* Переопределять существующие параметры.
* Изменять поведение приложения.
* Получать доступ к несанкционированным данным.

* **Защита**
Чтобы предотвратить загрязнение параметров на стороне сервера, используйте список разрешенных символов для определения символов, которые не требуют кодирования, и убедитесь, что все остальные входные данные пользователя кодируются перед включением в запрос на стороне сервера. Вам также следует убедиться, что все входные данные соответствуют ожидаемому формату и структуре.
