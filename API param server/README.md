* Описание


# Загрязнение параметров API на стороне сервера (HTTP Parameter Pollution)

> Некоторые системы содержат внутренние API, которые не доступны напрямую из Интернета. Загрязнение параметров на стороне сервера происходит, когда веб-сайт встраивает пользовательский ввод в запрос на стороне сервера к внутреннему API без адекватного кодирования. 

* **Точки входа**
  
* Параметры запроса
* Поля формы
* Заголовки 
* Параметры пути URL

* **Виды**

*	В строке запроса:

         #, & и =, добавить во входные данные и понаблюдайте за реакцией приложения.
 	
  * Усечение строк запроса

        GET /users/search?name=user#foo&publicProfile=true
    
    > Необходимо закодировать символ # в URL. В противном случае приложение фронтенда будет интерпретировать его как идентификатор фрагмента и не будет передано во внутренний API.

  * Внедрение недопустимых параметров

        GET /userSearch?name=user%26foo=xyz&back=/home
    > если ответ не изменился, это может означать, что параметр был успешно внедрен, но проигнорирован приложением.
    
  * Внедрение допустимых параметров

  * Переопределение существующих параметров

        GET /userSearch?name=user%26name=admins&back=/home

      > PHP анализирует только последний параметр. Это приведет к поиску пользователем admin.
      > 
      > ASP.NET объединяет оба параметра. Это приведет к поиску пользователя по запросу user,admin что может привести к сообщению об ошибке Invalid username.
      > 
      > Node.js / express анализирует только первый параметр. Это приведет к поиску пользователя по слову user, что даст неизменный результат.






  
  
+ Необходимо закодировать символ в URL.
GET /userSearch?name=peter&back=/home
сервер запрашивает внутренний API со следующим запросом:
GET /users/search?name=peter&publicProfile=true
* # - Усечение строк запроса (%23foo&)
GET /userSearch?name=peter %23foo&  back=/home 
Если вы можете усечь запрос на стороне сервера, это снимает требование, чтобы поле publicProfile было установлено в значение true. Вы можете использовать это для возврата непубличных профилей пользователей.
* & - Внедрение недопустимых параметров (%26foo=xyz)
GET /userSearch?name=peter %26foo=xyz  &back=/home
Просмотрите ответ на предмет подсказок о том, как анализируется дополнительный параметр. Например, если ответ не изменился, это может означать, что параметр был успешно внедрен, но проигнорирован приложением.
* = - Внедрение допустимых параметров
GET /userSearch?name=peter%26email=foo&back=/home
Просмотрите ответ на предмет подсказок о том, как анализируется дополнительный параметр.

*	В путях REST:
GET /edit_profile.php?name=peter
Это приводит к следующему запросу на стороне сервера:
GET /api/private/users/peter
* %2f..%2f - последовательности обхода пути для изменения параметров и понаблюдайте, как реагирует приложение.
GET /edit_profile.php?name=peter%2f..%2fadmin
Это может привести к следующему запросу на стороне сервера:
GET /api/private/users/peter/../admin
Example:
param%23
param%3F
./param
../param%23
../../../%23
Not found. Это означает, что вы вышли за пределы корня API.
username=../../../../openapi.json%23 (swagger.json, openapi.yaml, api-docs.json, apidoc.json, schema.json, docs)

*	В структурированных форматах данных:
POST /myaccount
{"name": "peter\",\"access_level\":\"administrator"}
PATCH /users/7312/update
{"name":"peter","access_level":"administrator"}
В ответах также может происходить внедрение структурированного формата. Например, это может произойти, если пользовательский ввод надежно хранится в базе данных, а затем встроен в ответ JSON из внутреннего API без адекватного кодирования. Обычно вы можете обнаружить и использовать внедрение структурированного формата в ответах так же, как и в запросах.

* **Профит**
* Переопределять существующие параметры.
* Изменять поведение приложения.
* Получать доступ к несанкционированным данным.

* **Защита**
Чтобы предотвратить загрязнение параметров на стороне сервера, используйте список разрешенных символов для определения символов, которые не требуют кодирования, и убедитесь, что все остальные входные данные пользователя кодируются перед включением в запрос на стороне сервера. Вам также следует убедиться, что все входные данные соответствуют ожидаемому формату и структуре.
